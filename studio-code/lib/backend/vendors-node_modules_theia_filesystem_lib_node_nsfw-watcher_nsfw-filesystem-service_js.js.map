{"version":3,"file":"vendors-node_modules_theia_filesystem_lib_node_nsfw-watcher_nsfw-filesystem-service_js.js","mappings":"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AAE;YACtB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,EAAE,GAAG,MAAM,CAAC,CAAC;SACzC;IACL,CAAC;IAED,OAAO;QACH,sCAAsC;IAC1C,CAAC;CACJ;AAvGD,oEAuGC;;;;;;;;;;;;ACheY;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;AC7DA,eAAe,mBAAO,CAAC,8DAAgB;;AAEvC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;AACA,mCAAmC;AACnC,oCAAoC;AACpC;AACA;AACA;;;AAGA;AACA;AACA,wCAAwC,GAAG,IAAI;AAC/C;AACA;AACA;;AAEA;AACA,qBAAqB,KAAK;;AAE1B;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B,uCAAuC,GAAG;AAC1C,YAAY,GAAG,yBAAyB;AACxC;AACA;AACA,8BAA8B;AAC9B,cAAc,GAAG;AACjB;;AAEA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,KAAK;AAC1B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,iBAAiB;AACrC,6BAA6B,eAAe;AAC5C;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,UAAU,EAAE;AACZ,6BAA6B;AAC7B,wBAAwB;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,cAAc,KAAK,QAAQ,EAAE,IAAI,EAAE;AACnC;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA,sBAAsB,cAAc;AACpC;AACA;AACA;;AAEA,oBAAoB,cAAc;AAClC,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;ACzMA;AACA;AACA;AACA,+BAA+B,YAAY,IAAI;;;;;;;;;;;ACH/C,4DAA4D;AAC5D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,aAAa,mBAAO,CAAC,2DAAe;AACpC;;AAEA;AACA;AACA,eAAe,mBAAO,CAAC,gEAAiB;;AAExC;AACA,SAAS,sCAAsC;AAC/C,SAAS,0BAA0B;AACnC,SAAS,0BAA0B;AACnC,SAAS,0BAA0B;AACnC,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,IAAI;;AAE/C;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA,CAAC,IAAI;;AAEL;AACA,kCAAkC;;AAElC;AACA;;AAEA;AACA;;AAEA,yCAAyC;AACzC;;AAEA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;AAMA;AACA,KAAK,IAAI;AACT,KAAK,GAAG;AACR,KAAK,KAAK;AACV,KAAK,IAAI,IAAI,EAAE;AACf,KAAK,IAAI,EAAE,IAAI;AACf;AACA;AACA,KAAK,IAAI,OAAO,IAAI;AACpB,KAAK,EAAE,OAAO,EAAE;AAChB;;AAEA,0CAA0C;AAC1C;;AAEA;AACA;AACA,6BAA6B,QAAQ,MAAM;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC;;AAEtC,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C;AAC5C;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,iDAAiD;AACrE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,4CAA4C;;AAEpD;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,IAAI;AAC/B;AACA;AACA;AACA;AACA;AACA,2BAA2B,IAAI;AAC/B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,iDAAiD;AACxE;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,kBAAkB;AACrE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,QAAQ;AACR,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,IAAI;AAC1C;AACA;AACA;AACA;AACA,kCAAkC,EAAE,EAAE,KAAK;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;;AAEA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC/6BA,QAAQ,eAAe,EAAE,mBAAO,CAAC,cAAI;AACrC,aAAa,mBAAO,CAAC,kBAAM;;AAE3B,aAAa,mBAAO,CAAC,kFAA+B;;AAEpD;AACA,UAAU,6BAA6B;AACvC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kCAAkC;AAC3D,QAAQ;AACR;AACA;AACA;AACA;AACA,yBAAyB,mCAAmC;AAC5D;AACA,MAAM;AACN;AACA;AACA,yBAAyB,kCAAkC;AAC3D;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA,IAAI,sEAAsE,IAAI;AAC9E;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA,4DAA4D,kBAAkB;;AAE9E;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA,gDAAgD,uBAAuB;AACvE;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD,0CAA0C;AAC1F,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA","sources":["webpack:////media/shomari/Workspace/avasdao/nexajs/studio-code/node_modules/nsfw/build/Release/nsfw.node?","webpack:////media/shomari/Workspace/avasdao/nexajs/studio-code/node_modules/@theia/core/shared/nsfw/index.js?","webpack:////media/shomari/Workspace/avasdao/nexajs/studio-code/node_modules/@theia/filesystem/src/node/file-change-collection.ts?","webpack:////media/shomari/Workspace/avasdao/nexajs/studio-code/node_modules/@theia/filesystem/src/node/nsfw-watcher/nsfw-filesystem-service.ts?","webpack:////media/shomari/Workspace/avasdao/nexajs/studio-code/node_modules/balanced-match/index.js?","webpack:////media/shomari/Workspace/avasdao/nexajs/studio-code/node_modules/brace-expansion/index.js?","webpack:////media/shomari/Workspace/avasdao/nexajs/studio-code/node_modules/minimatch/lib/path.js?","webpack:////media/shomari/Workspace/avasdao/nexajs/studio-code/node_modules/minimatch/minimatch.js?","webpack:////media/shomari/Workspace/avasdao/nexajs/studio-code/node_modules/nsfw/js/src/index.js?"],"sourcesContent":["\ntry {\n  process.dlopen(module, __dirname + require(\"path\").sep + __webpack_public_path__ + \"native/nsfw.node\");\n} catch (error) {\n  throw new Error('node-loader:\\n' + error);\n}\n","module.exports = require('nsfw');\n","// *****************************************************************************\n// Copyright (C) 2018 TypeFox and others.\n//\n// This program and the accompanying materials are made available under the\n// terms of the Eclipse Public License v. 2.0 which is available at\n// http://www.eclipse.org/legal/epl-2.0.\n//\n// This Source Code may also be made available under the following Secondary\n// Licenses when the conditions for such availability set forth in the Eclipse\n// Public License v. 2.0 are satisfied: GNU General Public License, version 2\n// with the GNU Classpath Exception which is available at\n// https://www.gnu.org/software/classpath/license.html.\n//\n// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0\n// *****************************************************************************\n\nimport { FileChange, FileChangeType } from '../common/filesystem-watcher-protocol';\n\n/**\n * A file change collection guarantees that only one change is reported for each URI.\n *\n * Changes are normalized according following rules:\n * - ADDED + ADDED => ADDED\n * - ADDED + UPDATED => ADDED\n * - ADDED + DELETED => [ADDED, DELETED]\n * - UPDATED + ADDED => UPDATED\n * - UPDATED + UPDATED => UPDATED\n * - UPDATED + DELETED => DELETED\n * - DELETED + ADDED => UPDATED\n * - DELETED + UPDATED => UPDATED\n * - DELETED + DELETED => DELETED\n */\nexport class FileChangeCollection {\n    protected readonly changes = new Map<string, FileChange[]>();\n\n    push(change: FileChange): void {\n        const changes = this.changes.get(change.uri) || [];\n        this.normalize(changes, change);\n        this.changes.set(change.uri, changes);\n    }\n\n    protected normalize(changes: FileChange[], change: FileChange): void {\n        let currentType;\n        let nextType: FileChangeType | [FileChangeType, FileChangeType] = change.type;\n        do {\n            const current = changes.pop();\n            currentType = current && current.type;\n            nextType = this.reduce(currentType, nextType);\n        } while (!Array.isArray(nextType) && currentType !== undefined && currentType !== nextType);\n\n        const uri = change.uri;\n        if (Array.isArray(nextType)) {\n            changes.push(...nextType.map(type => ({ uri, type })));\n        } else {\n            changes.push({ uri, type: nextType });\n        }\n    }\n\n    protected reduce(current: FileChangeType | undefined, change: FileChangeType): FileChangeType | [FileChangeType, FileChangeType] {\n        if (current === undefined) {\n            return change;\n        }\n        if (current === FileChangeType.ADDED) {\n            if (change === FileChangeType.DELETED) {\n                return [FileChangeType.ADDED, FileChangeType.DELETED];\n            }\n            return FileChangeType.ADDED;\n        }\n        if (change === FileChangeType.DELETED) {\n            return FileChangeType.DELETED;\n        }\n        return FileChangeType.UPDATED;\n    }\n\n    values(): FileChange[] {\n        return Array.from(this.changes.values()).reduce((acc, val) => acc.concat(val), []);\n    }\n}\n","// *****************************************************************************\n// Copyright (C) 2017-2018 TypeFox and others.\n//\n// This program and the accompanying materials are made available under the\n// terms of the Eclipse Public License v. 2.0 which is available at\n// http://www.eclipse.org/legal/epl-2.0.\n//\n// This Source Code may also be made available under the following Secondary\n// Licenses when the conditions for such availability set forth in the Eclipse\n// Public License v. 2.0 are satisfied: GNU General Public License, version 2\n// with the GNU Classpath Exception which is available at\n// https://www.gnu.org/software/classpath/license.html.\n//\n// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0\n// *****************************************************************************\n\nimport nsfw = require('@theia/core/shared/nsfw');\nimport path = require('path');\nimport { promises as fsp } from 'fs';\nimport { IMinimatch, Minimatch } from 'minimatch';\nimport { FileUri } from '@theia/core/lib/node/file-uri';\nimport {\n    FileChangeType, FileSystemWatcherService, FileSystemWatcherServiceClient, WatchOptions\n} from '../../common/filesystem-watcher-protocol';\nimport { FileChangeCollection } from '../file-change-collection';\nimport { Deferred, timeout } from '@theia/core/lib/common/promise-util';\n\nexport interface NsfwWatcherOptions {\n    ignored: IMinimatch[]\n}\n\nexport const NsfwFileSystemWatcherServerOptions = Symbol('NsfwFileSystemWatcherServerOptions');\nexport interface NsfwFileSystemWatcherServerOptions {\n    verbose: boolean;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    info: (message: string, ...args: any[]) => void;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    error: (message: string, ...args: any[]) => void;\n    nsfwOptions: nsfw.Options;\n}\n\n/**\n * This is a flag value passed around upon disposal.\n */\nexport const WatcherDisposal = Symbol('WatcherDisposal');\n\n/**\n * Because URIs can be watched by different clients, we'll track\n * how many are listening for a given URI.\n *\n * This component wraps the whole start/stop process given some\n * reference count.\n *\n * Once there are no more references the handle\n * will wait for some time before destroying its resources.\n */\nexport class NsfwWatcher {\n\n    protected static debugIdSequence = 0;\n\n    protected disposed = false;\n\n    /**\n     * Used for debugging to keep track of the watchers.\n     */\n    protected debugId = NsfwWatcher.debugIdSequence++;\n\n    /**\n     * When this field is set, it means the nsfw instance was successfully started.\n     */\n    protected nsfw: nsfw.NSFW | undefined;\n\n    /**\n     * When the ref count hits zero, we schedule this watch handle to be disposed.\n     */\n    protected deferredDisposalTimer: NodeJS.Timer | undefined;\n\n    /**\n     * This deferred only rejects with `WatcherDisposal` and never resolves.\n     */\n    protected readonly deferredDisposalDeferred = new Deferred<never>();\n\n    /**\n     * We count each reference made to this watcher, per client.\n     *\n     * We do this to know where to send events via the network.\n     *\n     * An entry should be removed when its value hits zero.\n     */\n    protected readonly refsPerClient = new Map<number, { value: number }>();\n\n    /**\n     * Ensures that events are processed in the order they are emitted,\n     * despite being processed async.\n     */\n    protected nsfwEventProcessingQueue: Promise<void> = Promise.resolve();\n\n    /**\n     * Resolves once this handle disposed itself and its resources. Never throws.\n     */\n    readonly whenDisposed: Promise<void> = this.deferredDisposalDeferred.promise.catch(() => undefined);\n\n    /**\n     * Promise that resolves when the watcher is fully started, or got disposed.\n     *\n     * Will reject if an error occurred while starting.\n     *\n     * @returns `true` if successfully started, `false` if disposed early.\n     */\n    readonly whenStarted: Promise<boolean>;\n\n    constructor(\n        /** Initial reference to this handle. */\n        initialClientId: number,\n        /** Filesystem path to be watched. */\n        readonly fsPath: string,\n        /** Watcher-specific options */\n        readonly watcherOptions: NsfwWatcherOptions,\n        /** Logging and Nsfw options */\n        protected readonly nsfwFileSystemWatchServerOptions: NsfwFileSystemWatcherServerOptions,\n        /** The client to forward events to. */\n        protected readonly fileSystemWatcherClient: FileSystemWatcherServiceClient,\n        /** Amount of time in ms to wait once this handle is not referenced anymore. */\n        protected readonly deferredDisposalTimeout = 10_000,\n    ) {\n        this.refsPerClient.set(initialClientId, { value: 1 });\n        this.whenStarted = this.start().then(() => true, error => {\n            if (error === WatcherDisposal) {\n                return false;\n            }\n            this._dispose();\n            this.fireError();\n            throw error;\n        });\n        this.debug('NEW', `initialClientId=${initialClientId}`);\n    }\n\n    addRef(clientId: number): void {\n        let refs = this.refsPerClient.get(clientId);\n        if (typeof refs === 'undefined') {\n            this.refsPerClient.set(clientId, refs = { value: 1 });\n        } else {\n            refs.value += 1;\n        }\n        const totalRefs = this.getTotalReferences();\n        // If it was zero before, 1 means we were revived:\n        const revived = totalRefs === 1;\n        if (revived) {\n            this.onRefsRevive();\n        }\n        this.debug('REF++', `clientId=${clientId}, clientRefs=${refs.value}, totalRefs=${totalRefs}. revived=${revived}`);\n    }\n\n    removeRef(clientId: number): void {\n        const refs = this.refsPerClient.get(clientId);\n        if (typeof refs === 'undefined') {\n            this.info('WARN REF--', `removed one too many reference: clientId=${clientId}`);\n            return;\n        }\n        refs.value -= 1;\n        // We must remove the key from `this.clientReferences` because\n        // we list active clients by reading the keys of this map.\n        if (refs.value === 0) {\n            this.refsPerClient.delete(clientId);\n        }\n        const totalRefs = this.getTotalReferences();\n        const dead = totalRefs === 0;\n        if (dead) {\n            this.onRefsReachZero();\n        }\n        this.debug('REF--', `clientId=${clientId}, clientRefs=${refs.value}, totalRefs=${totalRefs}, dead=${dead}`);\n    }\n\n    /**\n     * All clients with at least one active reference.\n     */\n    getClientIds(): number[] {\n        return Array.from(this.refsPerClient.keys());\n    }\n\n    /**\n     * Add the references for each client together.\n     */\n    getTotalReferences(): number {\n        let total = 0;\n        for (const refs of this.refsPerClient.values()) {\n            total += refs.value;\n        }\n        return total;\n    }\n\n    /**\n     * Returns true if at least one client listens to this handle.\n     */\n    isInUse(): boolean {\n        return this.refsPerClient.size > 0;\n    }\n\n    /**\n     * @throws with {@link WatcherDisposal} if this instance is disposed.\n     */\n    protected assertNotDisposed(): void {\n        if (this.disposed) {\n            throw WatcherDisposal;\n        }\n    }\n\n    /**\n     * When starting a watcher, we'll first check and wait for the path to exists\n     * before running an NSFW watcher.\n     */\n    protected async start(): Promise<void> {\n        while (await fsp.stat(this.fsPath).then(() => false, () => true)) {\n            await timeout(500);\n            this.assertNotDisposed();\n        }\n        this.assertNotDisposed();\n        const watcher = await this.createNsfw();\n        this.assertNotDisposed();\n        await watcher.start();\n        this.debug('STARTED', `disposed=${this.disposed}`);\n        // The watcher could be disposed while it was starting, make sure to check for this:\n        if (this.disposed) {\n            await this.stopNsfw(watcher);\n            throw WatcherDisposal;\n        }\n        this.nsfw = watcher;\n    }\n\n    /**\n     * Given a started nsfw instance, gracefully shut it down.\n     */\n    protected async stopNsfw(watcher: nsfw.NSFW): Promise<void> {\n        await watcher.stop()\n            .then(() => 'success=true', error => error)\n            .then(status => this.debug('STOPPED', status));\n    }\n\n    protected async createNsfw(): Promise<nsfw.NSFW> {\n        const fsPath = await fsp.realpath(this.fsPath);\n        return nsfw(fsPath, events => this.handleNsfwEvents(events), {\n            ...this.nsfwFileSystemWatchServerOptions.nsfwOptions,\n            // The errorCallback is called whenever NSFW crashes *while* watching.\n            // See https://github.com/atom/github/issues/342\n            errorCallback: error => {\n                console.error(`NSFW service error on \"${fsPath}\":`, error);\n                this._dispose();\n                this.fireError();\n                // Make sure to call user's error handling code:\n                if (this.nsfwFileSystemWatchServerOptions.nsfwOptions.errorCallback) {\n                    this.nsfwFileSystemWatchServerOptions.nsfwOptions.errorCallback(error);\n                }\n            },\n        });\n    }\n\n    protected handleNsfwEvents(events: nsfw.FileChangeEvent[]): void {\n        // Only process events if someone is listening.\n        if (this.isInUse()) {\n            // This callback is async, but nsfw won't wait for it to finish before firing the next one.\n            // We will use a lock/queue to make sure everything is processed in the order it arrives.\n            this.nsfwEventProcessingQueue = this.nsfwEventProcessingQueue.then(async () => {\n                const fileChangeCollection = new FileChangeCollection();\n                await Promise.all(events.map(async event => {\n                    if (event.action === nsfw.actions.RENAMED) {\n                        const [oldPath, newPath] = await Promise.all([\n                            this.resolveEventPath(event.directory, event.oldFile),\n                            this.resolveEventPath(event.newDirectory, event.newFile),\n                        ]);\n                        this.pushFileChange(fileChangeCollection, FileChangeType.DELETED, oldPath);\n                        this.pushFileChange(fileChangeCollection, FileChangeType.ADDED, newPath);\n                    } else {\n                        const filePath = await this.resolveEventPath(event.directory, event.file!);\n                        if (event.action === nsfw.actions.CREATED) {\n                            this.pushFileChange(fileChangeCollection, FileChangeType.ADDED, filePath);\n                        } else if (event.action === nsfw.actions.DELETED) {\n                            this.pushFileChange(fileChangeCollection, FileChangeType.DELETED, filePath);\n                        } else if (event.action === nsfw.actions.MODIFIED) {\n                            this.pushFileChange(fileChangeCollection, FileChangeType.UPDATED, filePath);\n                        }\n                    }\n                }));\n                const changes = fileChangeCollection.values();\n                // If all changes are part of the ignored files, the collection will be empty.\n                if (changes.length > 0) {\n                    this.fileSystemWatcherClient.onDidFilesChanged({\n                        clients: this.getClientIds(),\n                        changes,\n                    });\n                }\n            }, console.error);\n        }\n    }\n\n    protected async resolveEventPath(directory: string, file: string): Promise<string> {\n        // nsfw already resolves symlinks, the paths should be clean already:\n        return path.resolve(directory, file);\n    }\n\n    protected pushFileChange(changes: FileChangeCollection, type: FileChangeType, filePath: string): void {\n        if (!this.isIgnored(filePath)) {\n            const uri = FileUri.create(filePath).toString();\n            changes.push({ type, uri });\n        }\n    }\n\n    protected fireError(): void {\n        this.fileSystemWatcherClient.onError({\n            clients: this.getClientIds(),\n            uri: this.fsPath,\n        });\n    }\n\n    /**\n     * When references hit zero, we'll schedule disposal for a bit later.\n     *\n     * This allows new references to reuse this watcher instead of creating a new one.\n     *\n     * e.g. A frontend disconnects for a few milliseconds before reconnecting again.\n     */\n    protected onRefsReachZero(): void {\n        this.deferredDisposalTimer = setTimeout(() => this._dispose(), this.deferredDisposalTimeout);\n    }\n\n    /**\n     * If we get new references after hitting zero, let's unschedule our disposal and keep watching.\n     */\n    protected onRefsRevive(): void {\n        if (this.deferredDisposalTimer) {\n            clearTimeout(this.deferredDisposalTimer);\n            this.deferredDisposalTimer = undefined;\n        }\n    }\n\n    protected isIgnored(filePath: string): boolean {\n        return this.watcherOptions.ignored.length > 0\n            && this.watcherOptions.ignored.some(m => m.match(filePath));\n    }\n\n    /**\n     * Internal disposal mechanism.\n     */\n    protected async _dispose(): Promise<void> {\n        if (!this.disposed) {\n            this.disposed = true;\n            this.deferredDisposalDeferred.reject(WatcherDisposal);\n            if (this.nsfw) {\n                this.stopNsfw(this.nsfw);\n                this.nsfw = undefined;\n            }\n            this.debug('DISPOSED');\n        }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    protected info(prefix: string, ...params: any[]): void {\n        this.nsfwFileSystemWatchServerOptions.info(`${prefix} NsfwWatcher(${this.debugId} at \"${this.fsPath}\"):`, ...params);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    protected debug(prefix: string, ...params: any[]): void {\n        if (this.nsfwFileSystemWatchServerOptions.verbose) {\n            this.info(prefix, ...params);\n        }\n    }\n}\n\n/**\n * Each time a client makes a watchRequest, we generate a unique watcherId for it.\n *\n * This watcherId will map to this handle type which keeps track of the clientId that made the request.\n */\nexport interface NsfwWatcherHandle {\n    clientId: number;\n    watcher: NsfwWatcher;\n}\n\nexport class NsfwFileSystemWatcherService implements FileSystemWatcherService {\n\n    protected client: FileSystemWatcherServiceClient | undefined;\n\n    protected watcherId = 0;\n    protected readonly watchers = new Map<string, NsfwWatcher>();\n    protected readonly watcherHandles = new Map<number, NsfwWatcherHandle>();\n\n    protected readonly options: NsfwFileSystemWatcherServerOptions;\n\n    /**\n     * `this.client` is undefined until someone sets it.\n     */\n    protected readonly maybeClient: FileSystemWatcherServiceClient = {\n        onDidFilesChanged: event => this.client?.onDidFilesChanged(event),\n        onError: event => this.client?.onError(event),\n    };\n\n    constructor(options?: Partial<NsfwFileSystemWatcherServerOptions>) {\n        this.options = {\n            nsfwOptions: {},\n            verbose: false,\n            info: (message, ...args) => console.info(message, ...args),\n            error: (message, ...args) => console.error(message, ...args),\n            ...options\n        };\n    }\n\n    setClient(client: FileSystemWatcherServiceClient | undefined): void {\n        this.client = client;\n    }\n\n    /**\n     * A specific client requests us to watch a given `uri` according to some `options`.\n     *\n     * We internally re-use all the same `(uri, options)` pairs.\n     */\n    async watchFileChanges(clientId: number, uri: string, options?: WatchOptions): Promise<number> {\n        const resolvedOptions = this.resolveWatchOptions(options);\n        const watcherKey = this.getWatcherKey(uri, resolvedOptions);\n        let watcher = this.watchers.get(watcherKey);\n        if (watcher === undefined) {\n            const fsPath = FileUri.fsPath(uri);\n            watcher = this.createWatcher(clientId, fsPath, resolvedOptions);\n            watcher.whenDisposed.then(() => this.watchers.delete(watcherKey));\n            this.watchers.set(watcherKey, watcher);\n        } else {\n            watcher.addRef(clientId);\n        }\n        const watcherId = this.watcherId++;\n        this.watcherHandles.set(watcherId, { clientId, watcher });\n        watcher.whenDisposed.then(() => this.watcherHandles.delete(watcherId));\n        return watcherId;\n    }\n\n    protected createWatcher(clientId: number, fsPath: string, options: WatchOptions): NsfwWatcher {\n        const watcherOptions: NsfwWatcherOptions = {\n            ignored: options.ignored\n                .map(pattern => new Minimatch(pattern, { dot: true })),\n        };\n        return new NsfwWatcher(clientId, fsPath, watcherOptions, this.options, this.maybeClient);\n    }\n\n    async unwatchFileChanges(watcherId: number): Promise<void> {\n        const handle = this.watcherHandles.get(watcherId);\n        if (handle === undefined) {\n            console.warn(`tried to de-allocate a disposed watcher: watcherId=${watcherId}`);\n        } else {\n            this.watcherHandles.delete(watcherId);\n            handle.watcher.removeRef(handle.clientId);\n        }\n    }\n\n    /**\n     * Given some `URI` and some `WatchOptions`, generate a unique key.\n     */\n    protected getWatcherKey(uri: string, options: WatchOptions): string {\n        return [\n            uri,\n            options.ignored.slice(0).sort().join()  // use a **sorted copy** of `ignored` as part of the key\n        ].join();\n    }\n\n    /**\n     * Return fully qualified options.\n     */\n    protected resolveWatchOptions(options?: WatchOptions): WatchOptions {\n        return {\n            ignored: [],\n            ...options,\n        };\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    protected debug(message: string, ...params: any[]): void {\n        if (this.options.verbose) {\n            this.options.info(message, ...params);\n        }\n    }\n\n    dispose(): void {\n        // Singletons shouldn't be disposed...\n    }\n}\n","'use strict';\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    if(a===b) {\n      return [ai, bi];\n    }\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n","var balanced = require('balanced-match');\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m) return [str];\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  if (/\\$$/.test(m.pre)) {    \n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre+ '{' + m.body + '}' + post[k];\n      expansions.push(expansion);\n    }\n  } else {\n    var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isSequence = isNumericSequence || isAlphaSequence;\n    var isOptions = m.body.indexOf(',') >= 0;\n    if (!isSequence && !isOptions) {\n      // {a},b}\n      if (m.post.match(/,.*\\}/)) {\n        str = m.pre + '{' + m.body + escClose + m.post;\n        return expand(str);\n      }\n      return [str];\n    }\n\n    var n;\n    if (isSequence) {\n      n = m.body.split(/\\.\\./);\n    } else {\n      n = parseCommaParts(m.body);\n      if (n.length === 1) {\n        // x{{a,b}}y ==> x{a}y x{b}y\n        n = expand(n[0], false).map(embrace);\n        if (n.length === 1) {\n          return post.map(function(p) {\n            return m.pre + n[0] + p;\n          });\n        }\n      }\n    }\n\n    // at this point, n is the parts, and we know it's not a comma set\n    // with a single entry.\n    var N;\n\n    if (isSequence) {\n      var x = numeric(n[0]);\n      var y = numeric(n[1]);\n      var width = Math.max(n[0].length, n[1].length)\n      var incr = n.length == 3\n        ? Math.abs(numeric(n[2]))\n        : 1;\n      var test = lte;\n      var reverse = y < x;\n      if (reverse) {\n        incr *= -1;\n        test = gte;\n      }\n      var pad = n.some(isPadded);\n\n      N = [];\n\n      for (var i = x; test(i, y); i += incr) {\n        var c;\n        if (isAlphaSequence) {\n          c = String.fromCharCode(i);\n          if (c === '\\\\')\n            c = '';\n        } else {\n          c = String(i);\n          if (pad) {\n            var need = width - c.length;\n            if (need > 0) {\n              var z = new Array(need + 1).join('0');\n              if (i < 0)\n                c = '-' + z + c.slice(1);\n              else\n                c = z + c;\n            }\n          }\n        }\n        N.push(c);\n      }\n    } else {\n      N = [];\n\n      for (var j = 0; j < n.length; j++) {\n        N.push.apply(N, expand(n[j], false));\n      }\n    }\n\n    for (var j = 0; j < N.length; j++) {\n      for (var k = 0; k < post.length; k++) {\n        var expansion = pre + N[j] + post[k];\n        if (!isTop || isSequence || expansion)\n          expansions.push(expansion);\n      }\n    }\n  }\n\n  return expansions;\n}\n\n","const isWindows = typeof process === 'object' &&\n  process &&\n  process.platform === 'win32'\nmodule.exports = isWindows ? { sep: '\\\\' } : { sep: '/' }\n","const minimatch = module.exports = (p, pattern, options = {}) => {\n  assertValidPattern(pattern)\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nmodule.exports = minimatch\n\nconst path = require('./lib/path.js')\nminimatch.sep = path.sep\n\nconst GLOBSTAR = Symbol('globstar **')\nminimatch.GLOBSTAR = GLOBSTAR\nconst expand = require('brace-expansion')\n\nconst plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// \"abc\" -> { a:true, b:true, c:true }\nconst charSet = s => s.split('').reduce((set, c) => {\n  set[c] = true\n  return set\n}, {})\n\n// characters that need to be escaped in RegExp.\nconst reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// characters that indicate we have to add the pattern start\nconst addPatternStartSet = charSet('[.(')\n\n// normalizes slashes.\nconst slashSplit = /\\/+/\n\nminimatch.filter = (pattern, options = {}) =>\n  (p, i, list) => minimatch(p, pattern, options)\n\nconst ext = (a, b = {}) => {\n  const t = {}\n  Object.keys(a).forEach(k => t[k] = a[k])\n  Object.keys(b).forEach(k => t[k] = b[k])\n  return t\n}\n\nminimatch.defaults = def => {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch\n  }\n\n  const orig = minimatch\n\n  const m = (p, pattern, options) => orig(p, pattern, ext(def, options))\n  m.Minimatch = class Minimatch extends orig.Minimatch {\n    constructor (pattern, options) {\n      super(pattern, ext(def, options))\n    }\n  }\n  m.Minimatch.defaults = options => orig.defaults(ext(def, options)).Minimatch\n  m.filter = (pattern, options) => orig.filter(pattern, ext(def, options))\n  m.defaults = options => orig.defaults(ext(def, options))\n  m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options))\n  m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options))\n  m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options))\n\n  return m\n}\n\n\n\n\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = (pattern, options) => braceExpand(pattern, options)\n\nconst braceExpand = (pattern, options = {}) => {\n  assertValidPattern(pattern)\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\nconst MAX_PATTERN_LENGTH = 1024 * 64\nconst assertValidPattern = pattern => {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern')\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long')\n  }\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nconst SUBPARSE = Symbol('subparse')\n\nminimatch.makeRe = (pattern, options) =>\n  new Minimatch(pattern, options || {}).makeRe()\n\nminimatch.match = (list, pattern, options = {}) => {\n  const mm = new Minimatch(pattern, options)\n  list = list.filter(f => mm.match(f))\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\n// replace stuff like \\* with *\nconst globUnescape = s => s.replace(/\\\\(.)/g, '$1')\nconst charUnescape = s => s.replace(/\\\\([^-\\]])/g, '$1')\nconst regExpEscape = s => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\nconst braExpEscape = s => s.replace(/[[\\]\\\\]/g, '\\\\$&')\n\nclass Minimatch {\n  constructor (pattern, options) {\n    assertValidPattern(pattern)\n\n    if (!options) options = {}\n\n    this.options = options\n    this.set = []\n    this.pattern = pattern\n    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape ||\n      options.allowWindowsEscape === false\n    if (this.windowsPathsNoEscape) {\n      this.pattern = this.pattern.replace(/\\\\/g, '/')\n    }\n    this.regexp = null\n    this.negate = false\n    this.comment = false\n    this.empty = false\n    this.partial = !!options.partial\n\n    // make the set of regexps etc.\n    this.make()\n  }\n\n  debug () {}\n\n  make () {\n    const pattern = this.pattern\n    const options = this.options\n\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true\n      return\n    }\n    if (!pattern) {\n      this.empty = true\n      return\n    }\n\n    // step 1: figure out negation, etc.\n    this.parseNegate()\n\n    // step 2: expand braces\n    let set = this.globSet = this.braceExpand()\n\n    if (options.debug) this.debug = (...args) => console.error(...args)\n\n    this.debug(this.pattern, set)\n\n    // step 3: now we have a set, so turn each one into a series of path-portion\n    // matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    set = this.globParts = set.map(s => s.split(slashSplit))\n\n    this.debug(this.pattern, set)\n\n    // glob --> regexps\n    set = set.map((s, si, set) => s.map(this.parse, this))\n\n    this.debug(this.pattern, set)\n\n    // filter out everything that didn't compile properly.\n    set = set.filter(s => s.indexOf(false) === -1)\n\n    this.debug(this.pattern, set)\n\n    this.set = set\n  }\n\n  parseNegate () {\n    if (this.options.nonegate) return\n\n    const pattern = this.pattern\n    let negate = false\n    let negateOffset = 0\n\n    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n      negate = !negate\n      negateOffset++\n    }\n\n    if (negateOffset) this.pattern = pattern.slice(negateOffset)\n    this.negate = negate\n  }\n\n  // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n  matchOne (file, pattern, partial) {\n    var options = this.options\n\n    this.debug('matchOne',\n      { 'this': this, file: file, pattern: pattern })\n\n    this.debug('matchOne', file.length, pattern.length)\n\n    for (var fi = 0,\n        pi = 0,\n        fl = file.length,\n        pl = pattern.length\n        ; (fi < fl) && (pi < pl)\n        ; fi++, pi++) {\n      this.debug('matchOne loop')\n      var p = pattern[pi]\n      var f = file[fi]\n\n      this.debug(pattern, p, f)\n\n      // should be impossible.\n      // some invalid regexp stuff in the set.\n      /* istanbul ignore if */\n      if (p === false) return false\n\n      if (p === GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f])\n\n        // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n        var fr = fi\n        var pr = pi + 1\n        if (pr === pl) {\n          this.debug('** at the end')\n          // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n          for (; fi < fl; fi++) {\n            if (file[fi] === '.' || file[fi] === '..' ||\n              (!options.dot && file[fi].charAt(0) === '.')) return false\n          }\n          return true\n        }\n\n        // ok, let's see if we can swallow whatever we can.\n        while (fr < fl) {\n          var swallowee = file[fr]\n\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n          // XXX remove this slice.  Just pass the start index.\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee)\n            // found a match.\n            return true\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (swallowee === '.' || swallowee === '..' ||\n              (!options.dot && swallowee.charAt(0) === '.')) {\n              this.debug('dot detected!', file, fr, pattern, pr)\n              break\n            }\n\n            // ** swallows a segment, and continue.\n            this.debug('globstar swallow a segment, and continue')\n            fr++\n          }\n        }\n\n        // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        // If there's more *pattern* left, then\n        /* istanbul ignore if */\n        if (partial) {\n          // ran out of file\n          this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n          if (fr === fl) return true\n        }\n        return false\n      }\n\n      // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n      var hit\n      if (typeof p === 'string') {\n        hit = f === p\n        this.debug('string match', p, f, hit)\n      } else {\n        hit = f.match(p)\n        this.debug('pattern match', p, f, hit)\n      }\n\n      if (!hit) return false\n    }\n\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial\n    } else /* istanbul ignore else */ if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return (fi === fl - 1) && (file[fi] === '')\n    }\n\n    // should be unreachable.\n    /* istanbul ignore next */\n    throw new Error('wtf?')\n  }\n\n  braceExpand () {\n    return braceExpand(this.pattern, this.options)\n  }\n\n  parse (pattern, isSub) {\n    assertValidPattern(pattern)\n\n    const options = this.options\n\n    // shortcuts\n    if (pattern === '**') {\n      if (!options.noglobstar)\n        return GLOBSTAR\n      else\n        pattern = '*'\n    }\n    if (pattern === '') return ''\n\n    let re = ''\n    let hasMagic = false\n    let escaping = false\n    // ? => one single character\n    const patternListStack = []\n    const negativeLists = []\n    let stateChar\n    let inClass = false\n    let reClassStart = -1\n    let classStart = -1\n    let cs\n    let pl\n    let sp\n    // . and .. never match anything that doesn't start with .,\n    // even when options.dot is set.  However, if the pattern\n    // starts with ., then traversal patterns can match.\n    let dotTravAllowed = pattern.charAt(0) === '.'\n    let dotFileAllowed = options.dot || dotTravAllowed\n    const patternStart = () =>\n      dotTravAllowed\n        ? ''\n        : dotFileAllowed\n        ? '(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))'\n        : '(?!\\\\.)'\n    const subPatternStart = (p) =>\n      p.charAt(0) === '.'\n        ? ''\n        : options.dot\n        ? '(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))'\n        : '(?!\\\\.)'\n\n\n    const clearStateChar = () => {\n      if (stateChar) {\n        // we had some state-tracking character\n        // that wasn't consumed by this pass.\n        switch (stateChar) {\n          case '*':\n            re += star\n            hasMagic = true\n          break\n          case '?':\n            re += qmark\n            hasMagic = true\n          break\n          default:\n            re += '\\\\' + stateChar\n          break\n        }\n        this.debug('clearStateChar %j %j', stateChar, re)\n        stateChar = false\n      }\n    }\n\n    for (let i = 0, c; (i < pattern.length) && (c = pattern.charAt(i)); i++) {\n      this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n      // skip over any that are escaped.\n      if (escaping) {\n        /* istanbul ignore next - completely not allowed, even escaped. */\n        if (c === '/') {\n          return false\n        }\n\n        if (reSpecials[c]) {\n          re += '\\\\'\n        }\n        re += c\n        escaping = false\n        continue\n      }\n\n      switch (c) {\n        /* istanbul ignore next */\n        case '/': {\n          // Should already be path-split by now.\n          return false\n        }\n\n        case '\\\\':\n          if (inClass && pattern.charAt(i + 1) === '-') {\n            re += c\n            continue\n          }\n\n          clearStateChar()\n          escaping = true\n        continue\n\n        // the various stateChar values\n        // for the \"extglob\" stuff.\n        case '?':\n        case '*':\n        case '+':\n        case '@':\n        case '!':\n          this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n          // all of those are literals inside a class, except that\n          // the glob [!a] means [^a] in regexp\n          if (inClass) {\n            this.debug('  in class')\n            if (c === '!' && i === classStart + 1) c = '^'\n            re += c\n            continue\n          }\n\n          // if we already have a stateChar, then it means\n          // that there was something like ** or +? in there.\n          // Handle the stateChar, then proceed with this one.\n          this.debug('call clearStateChar %j', stateChar)\n          clearStateChar()\n          stateChar = c\n          // if extglob is disabled, then +(asdf|foo) isn't a thing.\n          // just clear the statechar *now*, rather than even diving into\n          // the patternList stuff.\n          if (options.noext) clearStateChar()\n        continue\n\n        case '(': {\n          if (inClass) {\n            re += '('\n            continue\n          }\n\n          if (!stateChar) {\n            re += '\\\\('\n            continue\n          }\n\n          const plEntry = {\n            type: stateChar,\n            start: i - 1,\n            reStart: re.length,\n            open: plTypes[stateChar].open,\n            close: plTypes[stateChar].close,\n          }\n          this.debug(this.pattern, '\\t', plEntry)\n          patternListStack.push(plEntry)\n          // negation is (?:(?!(?:js)(?:<rest>))[^/]*)\n          re += plEntry.open\n          // next entry starts with a dot maybe?\n          if (plEntry.start === 0 && plEntry.type !== '!') {\n            dotTravAllowed = true\n            re += subPatternStart(pattern.slice(i + 1))\n          }\n          this.debug('plType %j %j', stateChar, re)\n          stateChar = false\n          continue\n        }\n\n        case ')': {\n          const plEntry = patternListStack[patternListStack.length - 1]\n          if (inClass || !plEntry) {\n            re += '\\\\)'\n            continue\n          }\n          patternListStack.pop()\n\n          // closing an extglob\n          clearStateChar()\n          hasMagic = true\n          pl = plEntry\n          // negation is (?:(?!js)[^/]*)\n          // The others are (?:<pattern>)<type>\n          re += pl.close\n          if (pl.type === '!') {\n            negativeLists.push(Object.assign(pl, { reEnd: re.length }))\n          }\n          continue\n        }\n\n        case '|': {\n          const plEntry = patternListStack[patternListStack.length - 1]\n          if (inClass || !plEntry) {\n            re += '\\\\|'\n            continue\n          }\n\n          clearStateChar()\n          re += '|'\n          // next subpattern can start with a dot?\n          if (plEntry.start === 0 && plEntry.type !== '!') {\n            dotTravAllowed = true\n            re += subPatternStart(pattern.slice(i + 1))\n          }\n          continue\n        }\n\n        // these are mostly the same in regexp and glob\n        case '[':\n          // swallow any state-tracking char before the [\n          clearStateChar()\n\n          if (inClass) {\n            re += '\\\\' + c\n            continue\n          }\n\n          inClass = true\n          classStart = i\n          reClassStart = re.length\n          re += c\n        continue\n\n        case ']':\n          //  a right bracket shall lose its special\n          //  meaning and represent itself in\n          //  a bracket expression if it occurs\n          //  first in the list.  -- POSIX.2 2.8.3.2\n          if (i === classStart + 1 || !inClass) {\n            re += '\\\\' + c\n            continue\n          }\n\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + braExpEscape(charUnescape(cs)) + ']')\n            // looks good, finish up the class.\n            re += c\n          } catch (er) {\n            // out of order ranges in JS are errors, but in glob syntax,\n            // they're just a range that matches nothing.\n            re = re.substring(0, reClassStart) + '(?:$.)' // match nothing ever\n          }\n          hasMagic = true\n          inClass = false\n        continue\n\n        default:\n          // swallow any state char that wasn't consumed\n          clearStateChar()\n\n          if (reSpecials[c] && !(c === '^' && inClass)) {\n            re += '\\\\'\n          }\n\n          re += c\n          break\n\n      } // switch\n    } // for\n\n    // handle the case where we left a class open.\n    // \"[abc\" is valid, equivalent to \"\\[abc\"\n    if (inClass) {\n      // split where the last [ was, and escape it\n      // this is a huge pita.  We now have to re-walk\n      // the contents of the would-be class to re-translate\n      // any characters that were passed through as-is\n      cs = pattern.slice(classStart + 1)\n      sp = this.parse(cs, SUBPARSE)\n      re = re.substring(0, reClassStart) + '\\\\[' + sp[0]\n      hasMagic = hasMagic || sp[1]\n    }\n\n    // handle the case where we had a +( thing at the *end*\n    // of the pattern.\n    // each pattern list stack adds 3 chars, and we need to go through\n    // and escape any | chars that were passed through as-is for the regexp.\n    // Go through and escape them, taking care not to double-escape any\n    // | chars that were already escaped.\n    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n      let tail\n      tail = re.slice(pl.reStart + pl.open.length)\n      this.debug('setting tail', re, pl)\n      // maybe some even number of \\, then maybe 1 \\, followed by a |\n      tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, (_, $1, $2) => {\n        /* istanbul ignore else - should already be done */\n        if (!$2) {\n          // the | isn't already escaped, so escape it.\n          $2 = '\\\\'\n        }\n\n        // need to escape all those slashes *again*, without escaping the\n        // one that we need for escaping the | character.  As it works out,\n        // escaping an even number of slashes can be done by simply repeating\n        // it exactly after itself.  That's why this trick works.\n        //\n        // I am sorry that you have to see this.\n        return $1 + $1 + $2 + '|'\n      })\n\n      this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n      const t = pl.type === '*' ? star\n        : pl.type === '?' ? qmark\n        : '\\\\' + pl.type\n\n      hasMagic = true\n      re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n    }\n\n    // handle trailing things that only matter at the very end.\n    clearStateChar()\n    if (escaping) {\n      // trailing \\\\\n      re += '\\\\\\\\'\n    }\n\n    // only need to apply the nodot start if the re starts with\n    // something that could conceivably capture a dot\n    const addPatternStart = addPatternStartSet[re.charAt(0)]\n\n    // Hack to work around lack of negative lookbehind in JS\n    // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n    // like 'a.xyz.yz' doesn't match.  So, the first negative\n    // lookahead, has to look ALL the way ahead, to the end of\n    // the pattern.\n    for (let n = negativeLists.length - 1; n > -1; n--) {\n      const nl = negativeLists[n]\n\n      const nlBefore = re.slice(0, nl.reStart)\n      const nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n      let nlAfter = re.slice(nl.reEnd)\n      const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter\n\n      // Handle nested stuff like *(*.js|!(*.json)), where open parens\n      // mean that we should *not* include the ) in the bit that is considered\n      // \"after\" the negated section.\n      const closeParensBefore = nlBefore.split(')').length\n      const openParensBefore = nlBefore.split('(').length - closeParensBefore\n      let cleanAfter = nlAfter\n      for (let i = 0; i < openParensBefore; i++) {\n        cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n      }\n      nlAfter = cleanAfter\n\n      const dollar = nlAfter === '' && isSub !== SUBPARSE ? '(?:$|\\\\/)' : ''\n\n      re = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    }\n\n    // if the re is not \"\" at this point, then we need to make sure\n    // it doesn't match against an empty path part.\n    // Otherwise a/* will match a/, which it should not.\n    if (re !== '' && hasMagic) {\n      re = '(?=.)' + re\n    }\n\n    if (addPatternStart) {\n      re = patternStart() + re\n    }\n\n    // parsing just a piece of a larger pattern.\n    if (isSub === SUBPARSE) {\n      return [re, hasMagic]\n    }\n\n    // if it's nocase, and the lcase/uppercase don't match, it's magic\n    if (options.nocase && !hasMagic) {\n      hasMagic = pattern.toUpperCase() !== pattern.toLowerCase()\n    }\n\n    // skip the regexp for non-magical patterns\n    // unescape anything in it, though, so that it'll be\n    // an exact match against a file etc.\n    if (!hasMagic) {\n      return globUnescape(pattern)\n    }\n\n    const flags = options.nocase ? 'i' : ''\n    try {\n      return Object.assign(new RegExp('^' + re + '$', flags), {\n        _glob: pattern,\n        _src: re,\n      })\n    } catch (er) /* istanbul ignore next - should be impossible */ {\n      // If it was an invalid regular expression, then it can't match\n      // anything.  This trick looks for a character after the end of\n      // the string, which is of course impossible, except in multi-line\n      // mode, but it's not a /m regex.\n      return new RegExp('$.')\n    }\n  }\n\n  makeRe () {\n    if (this.regexp || this.regexp === false) return this.regexp\n\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    const set = this.set\n\n    if (!set.length) {\n      this.regexp = false\n      return this.regexp\n    }\n    const options = this.options\n\n    const twoStar = options.noglobstar ? star\n      : options.dot ? twoStarDot\n      : twoStarNoDot\n    const flags = options.nocase ? 'i' : ''\n\n    // coalesce globstars and regexpify non-globstar patterns\n    // if it's the only item, then we just do one twoStar\n    // if it's the first, and there are more, prepend (\\/|twoStar\\/)? to next\n    // if it's the last, append (\\/twoStar|) to previous\n    // if it's in the middle, append (\\/|\\/twoStar\\/) to previous\n    // then filter out GLOBSTAR symbols\n    let re = set.map(pattern => {\n      pattern = pattern.map(p =>\n        typeof p === 'string' ? regExpEscape(p)\n        : p === GLOBSTAR ? GLOBSTAR\n        : p._src\n      ).reduce((set, p) => {\n        if (!(set[set.length - 1] === GLOBSTAR && p === GLOBSTAR)) {\n          set.push(p)\n        }\n        return set\n      }, [])\n      pattern.forEach((p, i) => {\n        if (p !== GLOBSTAR || pattern[i-1] === GLOBSTAR) {\n          return\n        }\n        if (i === 0) {\n          if (pattern.length > 1) {\n            pattern[i+1] = '(?:\\\\\\/|' + twoStar + '\\\\\\/)?' + pattern[i+1]\n          } else {\n            pattern[i] = twoStar\n          }\n        } else if (i === pattern.length - 1) {\n          pattern[i-1] += '(?:\\\\\\/|' + twoStar + ')?'\n        } else {\n          pattern[i-1] += '(?:\\\\\\/|\\\\\\/' + twoStar + '\\\\\\/)' + pattern[i+1]\n          pattern[i+1] = GLOBSTAR\n        }\n      })\n      return pattern.filter(p => p !== GLOBSTAR).join('/')\n    }).join('|')\n\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = '^(?:' + re + ')$'\n\n    // can match anything, as long as it's not this.\n    if (this.negate) re = '^(?!' + re + ').*$'\n\n    try {\n      this.regexp = new RegExp(re, flags)\n    } catch (ex) /* istanbul ignore next - should be impossible */ {\n      this.regexp = false\n    }\n    return this.regexp\n  }\n\n  match (f, partial = this.partial) {\n    this.debug('match', f, this.pattern)\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) return false\n    if (this.empty) return f === ''\n\n    if (f === '/' && partial) return true\n\n    const options = this.options\n\n    // windows: need to use /, not \\\n    if (path.sep !== '/') {\n      f = f.split(path.sep).join('/')\n    }\n\n    // treat the test path as a set of pathparts.\n    f = f.split(slashSplit)\n    this.debug(this.pattern, 'split', f)\n\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n\n    const set = this.set\n    this.debug(this.pattern, 'set', set)\n\n    // Find the basename of the path by looking for the last non-empty segment\n    let filename\n    for (let i = f.length - 1; i >= 0; i--) {\n      filename = f[i]\n      if (filename) break\n    }\n\n    for (let i = 0; i < set.length; i++) {\n      const pattern = set[i]\n      let file = f\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename]\n      }\n      const hit = this.matchOne(file, pattern, partial)\n      if (hit) {\n        if (options.flipNegate) return true\n        return !this.negate\n      }\n    }\n\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) return false\n    return this.negate\n  }\n\n  static defaults (def) {\n    return minimatch.defaults(def).Minimatch\n  }\n}\n\nminimatch.Minimatch = Minimatch\n","const { promises: fs } = require('fs');\nconst path = require('path');\n\nconst NSFW = require('../../build/Release/nsfw.node');\n\nfunction NSFWFilePoller(watchPath, eventCallback, debounceMS) {\n  const { CREATED, DELETED, MODIFIED } = nsfw.actions;\n  const directory = path.dirname(watchPath);\n  const file = path.basename(watchPath);\n\n  let fileStatus;\n  let filePollerInterval;\n\n  const getStatus = async () => {\n    try {\n      const status = await fs.stat(watchPath);\n      if (fileStatus === null) {\n        fileStatus = status;\n        eventCallback([{ action: CREATED, directory, file }]);\n      } else if (\n        status.mtime - fileStatus.mtime !== 0 ||\n        status.ctime - fileStatus.ctime !== 0\n      ) {\n        fileStatus = status;\n        eventCallback([{ action: MODIFIED, directory, file }]);\n      }\n    } catch (e) {\n      if (fileStatus !== null) {\n        fileStatus = null;\n        eventCallback([{ action: DELETED, directory, file }]);\n      }\n    }\n  };\n\n  this.start = async () => {\n    try {\n      fileStatus = await fs.stat(watchPath);\n    } catch (e) {\n      fileStatus = null;\n    }\n\n    filePollerInterval = setInterval(getStatus, debounceMS);\n  };\n\n  this.stop = async () => {\n    clearInterval(filePollerInterval);\n  };\n\n  this.pause = () => this.stop();\n  this.resume = () => this.start();\n}\n\n\nconst buildNSFW = async (watchPath, eventCallback,\n  { debounceMS = 500, errorCallback: _errorCallback, excludedPaths = [] } = {}) => {\n  if (Number.isInteger(debounceMS)) {\n    if (debounceMS < 1) {\n      throw new Error('Minimum debounce is 1ms.');\n    }\n  } else {\n    throw new Error('debounceMS must be an integer.');\n  }\n\n  const errorCallback = _errorCallback || ((nsfwError) => { throw nsfwError; });\n\n  if (!path.isAbsolute(watchPath)) {\n    throw new Error('Path to watch must be an absolute path.');\n  }\n\n  let stats;\n  try {\n    stats = await fs.stat(watchPath);\n  } catch (e) {\n    throw new Error('Path must be a valid path to a file or a directory.');\n  }\n\n  if (excludedPaths) {\n    for (let i = 0; i < excludedPaths.length; i++) {\n      const excludedPath = excludedPaths[i];\n      if (process.platform === 'win32') {\n        if (!excludedPath.substring(0, watchPath.length - 1).\n          localeCompare(watchPath, undefined, { sensitivity: 'accent' })) {\n          throw new Error('Excluded path must be a valid subdirectory of the watching path.');\n        }\n      } else {\n        if (!excludedPath.startsWith(watchPath)) {\n          throw new Error('Excluded path must be a valid subdirectory of the watching path.');\n        }\n      }\n    }\n  }\n\n  if (stats.isDirectory()) {\n    return new NSFW(watchPath, eventCallback, { debounceMS, errorCallback, excludedPaths });\n  } else if (stats.isFile()) {\n    return new NSFWFilePoller(watchPath, eventCallback, debounceMS);\n  } else {\n    throw new Error('Path must be a valid path to a file or a directory');\n  }\n};\n\nfunction nsfw(watchPath, eventCallback, options) {\n  if (!(this instanceof nsfw)) {\n    return buildNSFW(watchPath, eventCallback, options).then(implementation => new nsfw(implementation));\n  }\n\n  const implementation = watchPath;\n\n  this.start = () => implementation.start();\n  this.stop = () => implementation.stop();\n  this.pause = () => implementation.pause();\n  this.resume = () => implementation.resume();\n  this.getExcludedPaths = () => implementation.getExcludedPaths();\n  this.updateExcludedPaths = (paths) => implementation.updateExcludedPaths(paths);\n}\n\n\nnsfw.actions = {\n  CREATED: 0,\n  DELETED: 1,\n  MODIFIED: 2,\n  RENAMED: 3\n};\n\nnsfw._native = NSFW;\n\nif (NSFW.getAllocatedInstanceCount) {\n  nsfw.getAllocatedInstanceCount = NSFW.getAllocatedInstanceCount;\n}\n\nmodule.exports = nsfw;\n"],"names":[],"sourceRoot":""}