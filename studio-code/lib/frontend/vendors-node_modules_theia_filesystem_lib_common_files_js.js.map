{"version":3,"file":"vendors-node_modules_theia_filesystem_lib_common_files_js.js","mappings":"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","sources":["webpack:///./node_modules/@theia/filesystem/src/common/files.ts?"],"sourcesContent":["// *****************************************************************************\n// Copyright (C) 2020 TypeFox and others.\n//\n// This program and the accompanying materials are made available under the\n// terms of the Eclipse Public License v. 2.0 which is available at\n// http://www.eclipse.org/legal/epl-2.0.\n//\n// This Source Code may also be made available under the following Secondary\n// Licenses when the conditions for such availability set forth in the Eclipse\n// Public License v. 2.0 are satisfied: GNU General Public License, version 2\n// with the GNU Classpath Exception which is available at\n// https://www.gnu.org/software/classpath/license.html.\n//\n// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0\n// *****************************************************************************\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// based on https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/platform/files/common/files.ts\n\nimport URI from '@theia/core/lib/common/uri';\nimport { Event } from '@theia/core/lib/common/event';\nimport { Disposable as IDisposable } from '@theia/core/lib/common/disposable';\nimport { BinaryBuffer, BinaryBufferReadableStream } from '@theia/core/lib/common/buffer';\nimport type { TextDocumentContentChangeEvent } from '@theia/core/shared/vscode-languageserver-protocol';\nimport { ReadableStreamEvents } from '@theia/core/lib/common/stream';\nimport { CancellationToken } from '@theia/core/lib/common/cancellation';\nimport { isObject } from '@theia/core/lib/common';\n\nexport const enum FileOperation {\n    CREATE,\n    DELETE,\n    MOVE,\n    COPY\n}\n\nexport class FileOperationEvent {\n\n    constructor(resource: URI, operation: FileOperation.DELETE);\n    constructor(resource: URI, operation: FileOperation.CREATE | FileOperation.MOVE | FileOperation.COPY, target: FileStatWithMetadata);\n    constructor(public readonly resource: URI, public readonly operation: FileOperation, public readonly target?: FileStatWithMetadata) { }\n\n    isOperation(operation: FileOperation.DELETE): boolean;\n    isOperation(operation: FileOperation.MOVE | FileOperation.COPY | FileOperation.CREATE): this is { readonly target: FileStatWithMetadata };\n    isOperation(operation: FileOperation): boolean {\n        return this.operation === operation;\n    }\n}\n\n/**\n * Possible changes that can occur to a file.\n */\nexport const enum FileChangeType {\n    UPDATED = 0,\n    ADDED = 1,\n    DELETED = 2\n}\n\n/**\n * Identifies a single change in a file.\n */\nexport interface FileChange {\n\n    /**\n     * The type of change that occurred to the file.\n     */\n    readonly type: FileChangeType;\n\n    /**\n     * The unified resource identifier of the file that changed.\n     */\n    readonly resource: URI;\n}\n\nexport class FileChangesEvent {\n\n    constructor(public readonly changes: readonly FileChange[]) { }\n\n    /**\n     * Returns true if this change event contains the provided file with the given change type (if provided). In case of\n     * type DELETED, this method will also return true if a folder got deleted that is the parent of the\n     * provided file path.\n     */\n    contains(resource: URI, type?: FileChangeType): boolean {\n        if (!resource) {\n            return false;\n        }\n\n        const checkForChangeType = typeof type === 'number';\n\n        return this.changes.some(change => {\n            if (checkForChangeType && change.type !== type) {\n                return false;\n            }\n\n            // For deleted also return true when deleted folder is parent of target path\n            if (change.type === FileChangeType.DELETED) {\n                return change.resource.isEqualOrParent(resource);\n            }\n\n            return change.resource.toString() === resource.toString();\n        });\n    }\n\n    /**\n     * Returns the changes that describe added files.\n     */\n    getAdded(): FileChange[] {\n        return this.getOfType(FileChangeType.ADDED);\n    }\n\n    /**\n     * Returns if this event contains added files.\n     */\n    gotAdded(): boolean {\n        return this.hasType(FileChangeType.ADDED);\n    }\n\n    /**\n     * Returns the changes that describe deleted files.\n     */\n    getDeleted(): FileChange[] {\n        return this.getOfType(FileChangeType.DELETED);\n    }\n\n    /**\n     * Returns if this event contains deleted files.\n     */\n    gotDeleted(): boolean {\n        return this.hasType(FileChangeType.DELETED);\n    }\n\n    /**\n     * Returns the changes that describe updated files.\n     */\n    getUpdated(): FileChange[] {\n        return this.getOfType(FileChangeType.UPDATED);\n    }\n\n    /**\n     * Returns if this event contains updated files.\n     */\n    gotUpdated(): boolean {\n        return this.hasType(FileChangeType.UPDATED);\n    }\n\n    private getOfType(type: FileChangeType): FileChange[] {\n        return this.changes.filter(change => change.type === type);\n    }\n\n    private hasType(type: FileChangeType): boolean {\n        return this.changes.some(change => change.type === type);\n    }\n}\n\nexport interface BaseStat {\n\n    /**\n     * The unified resource identifier of this file or folder.\n     */\n    resource: URI;\n\n    /**\n     * The name which is the last segment\n     * of the {{path}}.\n     */\n    name: string;\n\n    /**\n     * The size of the file.\n     *\n     * The value may or may not be resolved as\n     * it is optional.\n     */\n    size?: number;\n\n    /**\n     * The last modification date represented as millis from unix epoch.\n     *\n     * The value may or may not be resolved as\n     * it is optional.\n     */\n    mtime?: number;\n\n    /**\n     * The creation date represented as millis from unix epoch.\n     *\n     * The value may or may not be resolved as\n     * it is optional.\n     */\n    ctime?: number;\n\n    /**\n     * A unique identifier that represents the\n     * current state of the file or directory.\n     *\n     * The value may or may not be resolved as\n     * it is optional.\n     */\n    etag?: string;\n}\nexport namespace BaseStat {\n    export function is(arg: unknown): arg is BaseStat {\n        return isObject<BaseStat>(arg)\n            && arg.resource instanceof URI\n            && typeof arg.name === 'string';\n    }\n}\n\nexport interface BaseStatWithMetadata extends BaseStat {\n    mtime: number;\n    ctime: number;\n    etag: string;\n    size: number;\n}\n\n/**\n * A file resource with meta information.\n */\nexport interface FileStat extends BaseStat {\n\n    /**\n     * The resource is a file.\n     */\n    isFile: boolean;\n\n    /**\n     * The resource is a directory.\n     */\n    isDirectory: boolean;\n\n    /**\n     * The resource is a symbolic link.\n     */\n    isSymbolicLink: boolean;\n\n    /**\n     * The resource is read only.\n     */\n    isReadonly: boolean;\n\n    /**\n     * The children of the file stat or undefined if none.\n     */\n    children?: FileStat[];\n}\nexport namespace FileStat {\n    export function is(arg: unknown): arg is FileStat {\n        const fileStat = arg as FileStat;\n        return BaseStat.is(fileStat) &&\n            ('isFile' in fileStat && typeof fileStat.isFile === 'boolean') &&\n            ('isDirectory' in fileStat && typeof fileStat.isDirectory === 'boolean') &&\n            ('isSymbolicLink' in fileStat && typeof fileStat.isSymbolicLink === 'boolean');\n    }\n    export function asFileType(stat: FileStat): FileType {\n        let res = 0;\n        if (stat.isFile) {\n            res += FileType.File;\n\n        } else if (stat.isDirectory) {\n            res += FileType.Directory;\n        }\n        if (stat.isSymbolicLink) {\n            res += FileType.SymbolicLink;\n        }\n        return res;\n    }\n    export function toStat(stat: FileStat): Stat | { type: FileType } & Partial<Stat> {\n        return {\n            type: asFileType(stat),\n            ctime: stat.ctime,\n            mtime: stat.mtime,\n            size: stat.size\n        };\n    }\n    export function fromStat(resource: URI, stat: Stat): FileStatWithMetadata;\n    export function fromStat(resource: URI, stat: { type: FileType } & Partial<Stat>): FileStat;\n    export function fromStat(resource: URI, stat: Stat | { type: FileType } & Partial<Stat>): FileStat {\n        return {\n            resource,\n            name: resource.path.base || resource.path.toString(),\n            isFile: (stat.type & FileType.File) !== 0,\n            isDirectory: (stat.type & FileType.Directory) !== 0,\n            isSymbolicLink: (stat.type & FileType.SymbolicLink) !== 0,\n            isReadonly: !!stat.permissions && (stat.permissions & FilePermission.Readonly) !== 0,\n            mtime: stat.mtime,\n            ctime: stat.ctime,\n            size: stat.size,\n            etag: etag({ mtime: stat.mtime, size: stat.size })\n        };\n    }\n    export function dir(resource: string | URI, stat?: Partial<Omit<Stat, 'type'>>): FileStat {\n        return fromStat(resource instanceof URI ? resource : new URI(resource), { type: FileType.Directory, ...stat });\n    }\n    export function file(resource: string | URI, stat?: Partial<Omit<Stat, 'type'>>): FileStat {\n        return fromStat(resource instanceof URI ? resource : new URI(resource), { type: FileType.File, ...stat });\n    }\n}\n\nexport interface FileStatWithMetadata extends FileStat, BaseStatWithMetadata {\n    mtime: number;\n    ctime: number;\n    etag: string;\n    size: number;\n    children?: FileStatWithMetadata[];\n}\n\nexport interface ResolveFileResult {\n    stat?: FileStat;\n    success: boolean;\n}\n\nexport interface ResolveFileResultWithMetadata extends ResolveFileResult {\n    stat?: FileStatWithMetadata;\n}\n\nexport interface FileContent extends BaseStatWithMetadata {\n\n    /**\n     * The content of a file as buffer.\n     */\n    value: BinaryBuffer;\n}\n\nexport interface FileStreamContent extends BaseStatWithMetadata {\n\n    /**\n     * The content of a file as stream.\n     */\n    value: BinaryBufferReadableStream;\n}\n\nexport interface WriteFileOptions {\n\n    /**\n     * The last known modification time of the file. This can be used to prevent dirty writes.\n     */\n    readonly mtime?: number;\n\n    /**\n     * The etag of the file. This can be used to prevent dirty writes.\n     */\n    readonly etag?: string;\n}\n\nexport interface ReadFileOptions extends FileReadStreamOptions {\n\n    /**\n     * The optional etag parameter allows to return early from resolving the resource if\n     * the contents on disk match the etag. This prevents accumulated reading of resources\n     * that have been read already with the same etag.\n     * It is the task of the caller to makes sure to handle this error case from the promise.\n     */\n    readonly etag?: string;\n}\n\nexport interface WriteFileOptions {\n\n    /**\n     * The last known modification time of the file. This can be used to prevent dirty writes.\n     */\n    readonly mtime?: number;\n\n    /**\n     * The etag of the file. This can be used to prevent dirty writes.\n     */\n    readonly etag?: string;\n}\n\nexport interface ResolveFileOptions {\n\n    /**\n     * Automatically continue resolving children of a directory until the provided resources\n     * are found.\n     */\n    readonly resolveTo?: readonly URI[];\n\n    /**\n     * Automatically continue resolving children of a directory if the number of children is 1.\n     */\n    readonly resolveSingleChildDescendants?: boolean;\n\n    /**\n     * Will resolve mtime, ctime, size and etag of files if enabled. This can have a negative impact\n     * on performance and thus should only be used when these values are required.\n     */\n    readonly resolveMetadata?: boolean;\n}\n\nexport interface ResolveMetadataFileOptions extends ResolveFileOptions {\n    readonly resolveMetadata: true;\n}\n\nexport interface FileOperationOptions {\n    /**\n     * Indicates that a user action triggered the opening, e.g.\n     * via mouse or keyboard use. Default is true.\n     */\n    fromUserGesture?: boolean\n}\n\nexport interface MoveFileOptions extends FileOperationOptions, Partial<FileOverwriteOptions> {\n}\n\nexport interface CopyFileOptions extends FileOperationOptions, Partial<FileOverwriteOptions> {\n}\n\nexport interface CreateFileOptions extends FileOperationOptions, Partial<FileOverwriteOptions> {\n}\n\nexport class FileOperationError extends Error {\n    constructor(message: string, public fileOperationResult: FileOperationResult, public options?: ReadFileOptions & WriteFileOptions & CreateFileOptions) {\n        super(message);\n        Object.setPrototypeOf(this, FileOperationError.prototype);\n    }\n}\n\nexport const enum FileOperationResult {\n    FILE_IS_DIRECTORY,\n    FILE_NOT_FOUND,\n    FILE_NOT_MODIFIED_SINCE,\n    FILE_MODIFIED_SINCE,\n    FILE_MOVE_CONFLICT,\n    FILE_READ_ONLY,\n    FILE_PERMISSION_DENIED,\n    FILE_TOO_LARGE,\n    FILE_INVALID_PATH,\n    FILE_EXCEEDS_MEMORY_LIMIT,\n    FILE_NOT_DIRECTORY,\n    FILE_OTHER_ERROR\n}\n\nexport interface FileOverwriteOptions {\n    /**\n     * Overwrite the file to create if it already exists on disk. Otherwise\n     * an error will be thrown (FILE_MODIFIED_SINCE).\n     */\n    overwrite: boolean;\n}\n\nexport interface FileReadStreamOptions {\n\n    /**\n     * Is an integer specifying where to begin reading from in the file. If position is undefined,\n     * data will be read from the current file position.\n     */\n    readonly position?: number;\n\n    /**\n     * Is an integer specifying how many bytes to read from the file. By default, all bytes\n     * will be read.\n     */\n    readonly length?: number;\n\n    /**\n     * If provided, the size of the file will be checked against the limits.\n     */\n    limits?: {\n        readonly size?: number;\n        readonly memory?: number;\n    };\n}\n\nexport interface FileUpdateOptions {\n    readEncoding: string;\n    writeEncoding: string;\n    overwriteEncoding: boolean;\n}\nexport interface FileUpdateResult extends Stat {\n    encoding: string;\n}\n\nexport interface FileWriteOptions {\n    overwrite: boolean;\n    create: boolean;\n}\n\nexport interface FileOpenOptions {\n    create: boolean;\n}\n\nexport interface FileDeleteOptions {\n    recursive: boolean;\n    useTrash: boolean;\n}\n\nexport enum FileType {\n    Unknown = 0,\n    File = 1,\n    Directory = 2,\n    SymbolicLink = 64\n}\n\nexport enum FilePermission {\n\n    /**\n     * File is readonly.\n     */\n    Readonly = 1\n}\n\nexport interface Stat {\n    type: FileType;\n\n    /**\n     * The last modification date represented as millis from unix epoch.\n     */\n    mtime: number;\n\n    /**\n     * The creation date represented as millis from unix epoch.\n     */\n    ctime: number;\n\n    size: number;\n\n    permissions?: FilePermission;\n}\n\nexport interface WatchOptions {\n    recursive: boolean;\n    excludes: string[];\n}\n\nexport const enum FileSystemProviderCapabilities {\n    FileReadWrite = 1 << 1,\n    FileOpenReadWriteClose = 1 << 2,\n    FileReadStream = 1 << 4,\n\n    FileFolderCopy = 1 << 3,\n\n    PathCaseSensitive = 1 << 10,\n    Readonly = 1 << 11,\n\n    Trash = 1 << 12,\n\n    Access = 1 << 24,\n    Update = 1 << 25\n}\n\nexport enum FileSystemProviderErrorCode {\n    FileExists = 'EntryExists',\n    FileNotFound = 'EntryNotFound',\n    FileNotADirectory = 'EntryNotADirectory',\n    FileIsADirectory = 'EntryIsADirectory',\n    FileExceedsMemoryLimit = 'EntryExceedsMemoryLimit',\n    FileTooLarge = 'EntryTooLarge',\n    NoPermissions = 'NoPermissions',\n    Unavailable = 'Unavailable',\n    Unknown = 'Unknown'\n}\n\nexport class FileSystemProviderError extends Error {\n\n    constructor(message: string, public readonly code: FileSystemProviderErrorCode) {\n        super(message);\n        Object.setPrototypeOf(this, FileSystemProviderError.prototype);\n    }\n}\n\nexport function createFileSystemProviderError(error: Error | string, code: FileSystemProviderErrorCode): FileSystemProviderError {\n    const providerError = new FileSystemProviderError(error.toString(), code);\n    markAsFileSystemProviderError(providerError, code);\n\n    return providerError;\n}\n\nexport function ensureFileSystemProviderError(error?: Error): Error {\n    if (!error) {\n        return createFileSystemProviderError('Unknown Error', FileSystemProviderErrorCode.Unknown); // https://github.com/Microsoft/vscode/issues/72798\n    }\n\n    return error;\n}\n\nexport const FileSystemProvider = Symbol('FileSystemProvider');\n/**\n * A {@link FileSystemProvider} provides the capabilities to read, write, discover, and to manage files and folders\n * of the underlying (potentially virtual) file system. {@link FileSystemProvider}s can be used to serve files from both the\n * local disk as well as remote locations like ftp-servers, REST-services etc. A {@link FileSystemProvider} is registered for a certain\n * scheme and can handle all resources whose uri does conform to that scheme.\n */\nexport interface FileSystemProvider {\n\n    /** The {@link FileSystemProviderCapabilities} for this provider. */\n    readonly capabilities: FileSystemProviderCapabilities;\n\n    /** * Event that is fired if the capabilities of this provider have changed. */\n    readonly onDidChangeCapabilities: Event<void>;\n\n    /** Event that is fired if a (watched) file in the filesystem of this provider has changed. */\n    readonly onDidChangeFile: Event<readonly FileChange[]>;\n\n    /** Event that is fired if an error occurred when watching files in the filesystem of this provider. */\n    readonly onFileWatchError: Event<void>;\n\n    /**\n     * Watch the given resource and react to changes by firing the {@link FileSystemProvider#onDidChangeFile} event.\n     * @param resource `URI` of the resource to be watched.\n     * @param opts Options to define if the resource should be watched recursively and to\n     *  provide a set of resources that should be excluded from watching.\n     *\n     * @returns A `Disposable` that can be invoked to stop watching the resource.\n     */\n    watch(resource: URI, opts: WatchOptions): IDisposable;\n\n    /**\n     * Retrieve metadata about a given file.\n     *\n     * @param uri The `URI` of the file to retrieve meta data about.\n     * @returns A promise of the metadata about the resource.\n     */\n    stat(resource: URI): Promise<Stat>;\n\n    /**\n     * Create a new directory using the given resource uri.\n     * @param resource The `URI` of the new folder.\n     */\n    mkdir(resource: URI): Promise<void>;\n\n    /**\n     * Retrieve the content of a given directory.\n     * @param resource The `URI` of the directory.\n     *\n     * @returns A map containing the {@link FileType} for each child resource, identified by name.\n     */\n    readdir(resource: URI): Promise<[string, FileType][]>;\n\n    /**\n     * Delete the given resource.\n     * @param resource The `URI` of the resource to delete.\n     * @param opts Options to define if files should be deleted recursively and if the trash should be used.\n     */\n    delete(resource: URI, opts: FileDeleteOptions): Promise<void>;\n\n    /**\n     * Rename a file or folder.\n     * @param from `URI` of the existing file or folder.\n     * @param to `URI` of the target location.\n     * @param opts Options to define if existing files should be overwritten.\n     */\n    rename(from: URI, to: URI, opts: FileOverwriteOptions): Promise<void>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithFileFolderCopyCapability}.\n     * See {@link FileSystemProviderWithFileFolderCopyCapability#copy}} for additional documentation.\n     */\n    copy?(from: URI, to: URI, opts: FileOverwriteOptions): Promise<void>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithFileReadWriteCapability}.\n     * See {@link FileSystemProviderWithFileReadWriteCapability#readFile} for additional documentation.\n     */\n    readFile?(resource: URI): Promise<Uint8Array>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithFileReadWriteCapability}.\n     * See {@link FileSystemProviderWithFileReadWriteCapability#writeFile} for additional documentation.\n     */\n    writeFile?(resource: URI, content: Uint8Array, opts: FileWriteOptions): Promise<void>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithFileReadStreamCapability}.\n     * See {@link FileSystemProviderWithFileReadStreamCapability#readFileStream} for additional documentation.\n     */\n    readFileStream?(resource: URI, opts: FileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithOpenReadWriteCloseCapability}.\n     * See {@link FileSystemProviderWithOpenReadWriteCloseCapability#open} for additional documentation.\n     */\n    open?(resource: URI, opts: FileOpenOptions): Promise<number>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithOpenReadWriteCloseCapability}.\n     * See {@link FileSystemProviderWithOpenReadWriteCloseCapability#close} for additional documentation.\n     */\n    close?(fd: number): Promise<void>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithOpenReadWriteCloseCapability}.\n     * See {@link FileSystemProviderWithOpenReadWriteCloseCapability#read} for additional documentation.\n     */\n    read?(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithOpenReadWriteCloseCapability}.\n     * See {@link FileSystemProviderWithOpenReadWriteCloseCapability#write} for additional documentation.\n     */\n    write?(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithAccessCapability}.\n     * See {@link FileSystemProviderWithAccessCapability#access} for additional documentation.\n     */\n    access?(resource: URI, mode?: number): Promise<void>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithAccessCapability}.\n     * See {@link FileSystemProviderWithAccessCapability#fsPath} for additional documentation.\n     */\n    fsPath?(resource: URI): Promise<string>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithUpdateCapability}.\n     * See {@link FileSystemProviderWithUpdateCapability#updateFile} for additional documentation.\n     */\n    updateFile?(resource: URI, changes: TextDocumentContentChangeEvent[], opts: FileUpdateOptions): Promise<FileUpdateResult>;\n}\n\n/**\n * Subtype of {@link FileSystemProvider} that ensures that the optional functions needed for providers, that should be\n * able access files, are implemented.\n */\nexport interface FileSystemProviderWithAccessCapability extends FileSystemProvider {\n    /**\n     * Tests a user's permissions for the file or directory specified by URI.\n     * @param resource The `URI` of the file that should be tested.\n     * @param mode An optional integer that specifies the accessibility checks to be performed.\n     *      Check `FileAccess.Constants` for possible values of mode.\n     *      It is possible to create a mask consisting of the bitwise `OR` of two or more values (e.g. FileAccess.Constants.W_OK | FileAccess.Constants.R_OK).\n     *      If `mode` is not defined, `FileAccess.Constants.F_OK` will be used instead.\n     *\n     * @returns A promise that resolves if the user has the required permissions, should be rejected otherwise.\n     */\n    access(resource: URI, mode?: number): Promise<void>;\n\n    /**\n     * Returns the path of the given file URI, specific to the backend's operating system.\n     * If the URI is not a file URI, undefined is returned.\n     *\n     * USE WITH CAUTION: You should always prefer URIs to paths if possible, as they are\n     * portable and platform independent. Paths should only be used in cases you directly\n     * interact with the OS, e.g. when running a command on the shell.\n     *\n     * @param resource `URI` of the resource to derive the path from.\n     *\n     * @returns A promise of the corresponding file system path.\n     */\n    fsPath(resource: URI): Promise<string>;\n}\n\nexport function hasAccessCapability(provider: FileSystemProvider): provider is FileSystemProviderWithAccessCapability {\n    return !!(provider.capabilities & FileSystemProviderCapabilities.Access);\n}\n\n/**\n * Subtype of {@link FileSystemProvider} that ensures that the optional functions needed, for providers that should be\n * able to update (text) files, are implemented.\n */\nexport interface FileSystemProviderWithUpdateCapability extends FileSystemProvider {\n    /**\n     * Update the content of the given (text) file according to the given text document changes.\n     * @param resource `URI` of the resource to update.\n     * @param changes Array of events describing the changes to the file.\n     * @param opts The encoding options.\n     *\n     * @returns A promise of the file metadata that resolves after the update process has completed.\n     */\n    updateFile(resource: URI, changes: TextDocumentContentChangeEvent[], opts: FileUpdateOptions): Promise<FileUpdateResult>;\n}\n\nexport function hasUpdateCapability(provider: FileSystemProvider): provider is FileSystemProviderWithUpdateCapability {\n    return !!(provider.capabilities & FileSystemProviderCapabilities.Update);\n}\n\n/**\n * Subtype of {@link FileSystemProvider} that ensures that the optional functions, needed for providers\n * that should be able to read & write files, are implemented.\n */\nexport interface FileSystemProviderWithFileReadWriteCapability extends FileSystemProvider {\n    /**\n     * Read the contents of the given file as stream.\n     * @param resource The `URI` of the file.\n     *\n     * @return The `ReadableStreamEvents` for the readable stream of the given file.\n     */\n    readFile(resource: URI): Promise<Uint8Array>;\n\n    /**\n     *  Write data to a file, replacing its entire contents.\n     * @param resource The uri of the file.\n     * @param content The new content of the file.\n     * @param opts Options to define if the file should be created if missing and if an existing file should be overwritten.\n     */\n    writeFile(resource: URI, content: Uint8Array, opts: FileWriteOptions): Promise<void>;\n}\n\nexport function hasReadWriteCapability(provider: FileSystemProvider): provider is FileSystemProviderWithFileReadWriteCapability {\n    return !!(provider.capabilities & FileSystemProviderCapabilities.FileReadWrite);\n}\n\n/**\n * Subtype of {@link FileSystemProvider} that ensures that the optional functions, needed for providers that should be able to copy\n * file folders, are implemented.\n */\nexport interface FileSystemProviderWithFileFolderCopyCapability extends FileSystemProvider {\n    /**\n     * Copy files or folders.\n     * @param from `URI` of the existing file or folder.\n     * @param to `URI` of the destination location.\n     * @param opts Options to define if existing files should be overwritten.\n     */\n    copy(from: URI, to: URI, opts: FileOverwriteOptions): Promise<void>;\n}\n\nexport function hasFileFolderCopyCapability(provider: FileSystemProvider): provider is FileSystemProviderWithFileFolderCopyCapability {\n    return !!(provider.capabilities & FileSystemProviderCapabilities.FileFolderCopy);\n}\n\n/**\n * Subtype of {@link FileSystemProvider} that ensures that the optional functions, needed for providers that should be able to open,read, write\n * or close files, are implemented.\n */\nexport interface FileSystemProviderWithOpenReadWriteCloseCapability extends FileSystemProvider {\n    /**\n     * Open the give file.\n     * @param resource The `URI` of the file to open.\n     * @param opts Options to define if the file should be created if it does not exist yet.\n     *\n     * @returns A promise of the file descriptor that resolves after the file is open.\n     */\n    open(resource: URI, opts: FileOpenOptions): Promise<number>;\n\n    /**\n     * Close the file with the given file descriptor.\n     * @param fd the file descriptor to close.\n     */\n    close(fd: number): Promise<void>;\n\n    /**\n     * Read specified content from a given file descriptor into a data buffer.\n     * @param fd The file descriptor referencing the file to read from.\n     * @param pos The offset from the beginning of the file from which data should be read.\n     * @param data The buffer that the data will be written to.\n     * @param offset The offset in the buffer at which to start writing.\n     * @param length The number of bytes to read.\n     *\n     * @returns A promise of the number of bytes read.\n     */\n    read(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\n\n    /**\n     * Write specified content from the data buffer to the file referenced by the given file descriptor.\n     * @param fd The file descriptor referencing the file to write to.\n     * @param pos The offset from the beginning of the file where this data should be written.\n     * @param offset The part of the buffer to be read from.\n     * @param length The number of bytes to write.\n     *\n     * @returns A promise of the number of bytes written.\n     */\n    write(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\n}\n\nexport function hasOpenReadWriteCloseCapability(provider: FileSystemProvider): provider is FileSystemProviderWithOpenReadWriteCloseCapability {\n    return !!(provider.capabilities & FileSystemProviderCapabilities.FileOpenReadWriteClose);\n}\n\n/**\n * Subtype of {@link FileSystemProvider} that ensures that the optional functions, needed for providers that should be able to read\n * files as streams, are implemented.\n */\nexport interface FileSystemProviderWithFileReadStreamCapability extends FileSystemProvider {\n    /**\n     * Read the contents of the given file as stream.\n     * @param resource The `URI` of the file.\n     *\n     * @return The `ReadableStreamEvents` for the readable stream of the given file.\n     */\n    readFileStream(resource: URI, opts: FileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array>;\n}\n\nexport function hasFileReadStreamCapability(provider: FileSystemProvider): provider is FileSystemProviderWithFileReadStreamCapability {\n    return !!(provider.capabilities & FileSystemProviderCapabilities.FileReadStream);\n}\n\nexport function markAsFileSystemProviderError(error: Error, code: FileSystemProviderErrorCode): Error {\n    error.name = code ? `${code} (FileSystemError)` : 'FileSystemError';\n\n    return error;\n}\n\nexport function toFileSystemProviderErrorCode(error: Error | undefined | null): FileSystemProviderErrorCode {\n\n    // Guard against abuse\n    if (!error) {\n        return FileSystemProviderErrorCode.Unknown;\n    }\n\n    // FileSystemProviderError comes with the code\n    if (error instanceof FileSystemProviderError) {\n        return error.code;\n    }\n\n    // Any other error, check for name match by assuming that the error\n    // went through the markAsFileSystemProviderError() method\n    const match = /^(.+) \\(FileSystemError\\)$/.exec(error.name);\n    if (!match) {\n        return FileSystemProviderErrorCode.Unknown;\n    }\n\n    switch (match[1]) {\n        case FileSystemProviderErrorCode.FileExists: return FileSystemProviderErrorCode.FileExists;\n        case FileSystemProviderErrorCode.FileIsADirectory: return FileSystemProviderErrorCode.FileIsADirectory;\n        case FileSystemProviderErrorCode.FileNotADirectory: return FileSystemProviderErrorCode.FileNotADirectory;\n        case FileSystemProviderErrorCode.FileNotFound: return FileSystemProviderErrorCode.FileNotFound;\n        case FileSystemProviderErrorCode.FileExceedsMemoryLimit: return FileSystemProviderErrorCode.FileExceedsMemoryLimit;\n        case FileSystemProviderErrorCode.FileTooLarge: return FileSystemProviderErrorCode.FileTooLarge;\n        case FileSystemProviderErrorCode.NoPermissions: return FileSystemProviderErrorCode.NoPermissions;\n        case FileSystemProviderErrorCode.Unavailable: return FileSystemProviderErrorCode.Unavailable;\n    }\n\n    return FileSystemProviderErrorCode.Unknown;\n}\n\nexport function toFileOperationResult(error: Error): FileOperationResult {\n\n    // FileSystemProviderError comes with the result already\n    if (error instanceof FileOperationError) {\n        return error.fileOperationResult;\n    }\n\n    // Otherwise try to find from code\n    switch (toFileSystemProviderErrorCode(error)) {\n        case FileSystemProviderErrorCode.FileNotFound:\n            return FileOperationResult.FILE_NOT_FOUND;\n        case FileSystemProviderErrorCode.FileIsADirectory:\n            return FileOperationResult.FILE_IS_DIRECTORY;\n        case FileSystemProviderErrorCode.FileNotADirectory:\n            return FileOperationResult.FILE_NOT_DIRECTORY;\n        case FileSystemProviderErrorCode.NoPermissions:\n            return FileOperationResult.FILE_PERMISSION_DENIED;\n        case FileSystemProviderErrorCode.FileExists:\n            return FileOperationResult.FILE_MOVE_CONFLICT;\n        case FileSystemProviderErrorCode.FileExceedsMemoryLimit:\n            return FileOperationResult.FILE_EXCEEDS_MEMORY_LIMIT;\n        case FileSystemProviderErrorCode.FileTooLarge:\n            return FileOperationResult.FILE_TOO_LARGE;\n        default:\n            return FileOperationResult.FILE_OTHER_ERROR;\n    }\n}\n\n/**\n * A hint to disable etag checking for reading/writing.\n */\nexport const ETAG_DISABLED = '';\n\nexport function etag(stat: { mtime: number, size: number }): string;\nexport function etag(stat: { mtime: number | undefined, size: number | undefined }): string | undefined;\nexport function etag(stat: { mtime: number | undefined, size: number | undefined }): string | undefined {\n    if (typeof stat.size !== 'number' || typeof stat.mtime !== 'number') {\n        return undefined;\n    }\n\n    return stat.mtime.toString(29) + stat.size.toString(31);\n}\n/**\n * Helper to format a raw byte size into a human readable label.\n */\nexport class BinarySize {\n    static readonly KB = 1024;\n    static readonly MB = BinarySize.KB * BinarySize.KB;\n    static readonly GB = BinarySize.MB * BinarySize.KB;\n    static readonly TB = BinarySize.GB * BinarySize.KB;\n\n    static formatSize(size: number): string {\n        if (size < BinarySize.KB) {\n            return size + 'B';\n        }\n        if (size < BinarySize.MB) {\n            return (size / BinarySize.KB).toFixed(2) + 'KB';\n        }\n        if (size < BinarySize.GB) {\n            return (size / BinarySize.MB).toFixed(2) + 'MB';\n        }\n        if (size < BinarySize.TB) {\n            return (size / BinarySize.GB).toFixed(2) + 'GB';\n        }\n        return (size / BinarySize.TB).toFixed(2) + 'TB';\n    }\n}\n"],"names":[],"sourceRoot":""}