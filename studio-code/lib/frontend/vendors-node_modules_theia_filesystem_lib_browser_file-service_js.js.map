{"version":3,"file":"vendors-node_modules_theia_filesystem_lib_browser_file-service_js.js","mappings":"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","sources":["webpack:///./node_modules/@theia/core/shared/@theia/application-package/lib/environment/index.js?","webpack:///./node_modules/@theia/filesystem/src/browser/file-service.ts?","webpack:///./node_modules/@theia/filesystem/src/browser/filesystem-preferences.ts?","webpack:///./node_modules/@theia/filesystem/src/browser/filesystem-watcher-error-handler.ts?","webpack:///./node_modules/@theia/filesystem/src/common/delegating-file-system-provider.ts?","webpack:///./node_modules/@theia/filesystem/src/common/filesystem-utils.ts?","webpack:///./node_modules/@theia/filesystem/src/common/io.ts?"],"sourcesContent":["module.exports = require('@theia/application-package/lib/environment');\n","// *****************************************************************************\n// Copyright (C) 2020 TypeFox and others.\n//\n// This program and the accompanying materials are made available under the\n// terms of the Eclipse Public License v. 2.0 which is available at\n// http://www.eclipse.org/legal/epl-2.0.\n//\n// This Source Code may also be made available under the following Secondary\n// Licenses when the conditions for such availability set forth in the Eclipse\n// Public License v. 2.0 are satisfied: GNU General Public License, version 2\n// with the GNU Classpath Exception which is available at\n// https://www.gnu.org/software/classpath/license.html.\n//\n// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0\n// *****************************************************************************\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// based on https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/platform/files/common/fileService.ts\n// and https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/workbench/services/textfile/browser/textFileService.ts\n// and https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/workbench/services/textfile/electron-browser/nativeTextFileService.ts\n// and https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/workbench/services/workingCopy/common/workingCopyFileService.ts\n// and https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/workbench/services/workingCopy/common/workingCopyFileOperationParticipant.ts\n\n/* eslint-disable max-len */\n/* eslint-disable @typescript-eslint/no-shadow */\n/* eslint-disable no-null/no-null */\n/* eslint-disable @typescript-eslint/tslint/config */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { injectable, inject, named, postConstruct } from '@theia/core/shared/inversify';\nimport URI from '@theia/core/lib/common/uri';\nimport { timeout, Deferred } from '@theia/core/lib/common/promise-util';\nimport { CancellationToken, CancellationTokenSource } from '@theia/core/lib/common/cancellation';\nimport { Disposable, DisposableCollection } from '@theia/core/lib/common/disposable';\nimport { WaitUntilEvent, Emitter, AsyncEmitter, Event } from '@theia/core/lib/common/event';\nimport { ContributionProvider } from '@theia/core/lib/common/contribution-provider';\nimport { TernarySearchTree } from '@theia/core/lib/common/ternary-search-tree';\nimport {\n    ensureFileSystemProviderError, etag, ETAG_DISABLED,\n    FileChangesEvent,\n    FileOperation, FileOperationError,\n    FileOperationEvent, FileOperationResult, FileSystemProviderCapabilities,\n    FileSystemProviderErrorCode, FileType, hasFileFolderCopyCapability, hasOpenReadWriteCloseCapability, hasReadWriteCapability,\n    CreateFileOptions, FileContent, FileStat, FileStatWithMetadata,\n    FileStreamContent, FileSystemProvider,\n    FileSystemProviderWithFileReadWriteCapability, FileSystemProviderWithOpenReadWriteCloseCapability,\n    ReadFileOptions, ResolveFileOptions, ResolveMetadataFileOptions,\n    Stat, WatchOptions, WriteFileOptions,\n    toFileOperationResult, toFileSystemProviderErrorCode,\n    ResolveFileResult, ResolveFileResultWithMetadata,\n    MoveFileOptions, CopyFileOptions, BaseStatWithMetadata, FileDeleteOptions, FileOperationOptions, hasAccessCapability, hasUpdateCapability,\n    hasFileReadStreamCapability, FileSystemProviderWithFileReadStreamCapability\n} from '../common/files';\nimport { BinaryBuffer, BinaryBufferReadable, BinaryBufferReadableStream, BinaryBufferReadableBufferedStream, BinaryBufferWriteableStream } from '@theia/core/lib/common/buffer';\nimport { ReadableStream, isReadableStream, isReadableBufferedStream, transform, consumeStream, peekStream, peekReadable, Readable } from '@theia/core/lib/common/stream';\nimport { LabelProvider } from '@theia/core/lib/browser/label-provider';\nimport { FileSystemPreferences } from './filesystem-preferences';\nimport { ProgressService } from '@theia/core/lib/common/progress-service';\nimport { DelegatingFileSystemProvider } from '../common/delegating-file-system-provider';\nimport type { TextDocumentContentChangeEvent } from '@theia/core/shared/vscode-languageserver-protocol';\nimport { EncodingRegistry } from '@theia/core/lib/browser/encoding-registry';\nimport { UTF8, UTF8_with_bom } from '@theia/core/lib/common/encodings';\nimport { EncodingService, ResourceEncoding, DecodeStreamResult } from '@theia/core/lib/common/encoding-service';\nimport { Mutable } from '@theia/core/lib/common/types';\nimport { readFileIntoStream } from '../common/io';\nimport { FileSystemWatcherErrorHandler } from './filesystem-watcher-error-handler';\nimport { FileSystemUtils } from '../common/filesystem-utils';\nimport { nls } from '@theia/core';\n\nexport interface FileOperationParticipant {\n\n    /**\n     * Participate in a file operation of a working copy. Allows to\n     * change the working copy before it is being saved to disk.\n     */\n    participate(\n        target: URI,\n        source: URI | undefined,\n        operation: FileOperation,\n        timeout: number,\n        token: CancellationToken\n    ): Promise<void>;\n}\n\nexport interface ReadEncodingOptions {\n\n    /**\n     * The optional encoding parameter allows to specify the desired encoding when resolving\n     * the contents of the file.\n     */\n    encoding?: string;\n\n    /**\n     * The optional guessEncoding parameter allows to guess encoding from content of the file.\n     */\n    autoGuessEncoding?: boolean;\n}\n\nexport interface WriteEncodingOptions {\n\n    /**\n     * The encoding to use when updating a file.\n     */\n    encoding?: string;\n\n    /**\n     * If set to true, will enforce the selected encoding and not perform any detection using BOMs.\n     */\n    overwriteEncoding?: boolean;\n}\n\nexport interface ReadTextFileOptions extends ReadEncodingOptions, ReadFileOptions {\n    /**\n     * The optional acceptTextOnly parameter allows to fail this request early if the file\n     * contents are not textual.\n     */\n    acceptTextOnly?: boolean;\n}\n\ninterface BaseTextFileContent extends BaseStatWithMetadata {\n\n    /**\n     * The encoding of the content if known.\n     */\n    encoding: string;\n}\n\nexport interface TextFileContent extends BaseTextFileContent {\n\n    /**\n     * The content of a text file.\n     */\n    value: string;\n}\n\nexport interface TextFileStreamContent extends BaseTextFileContent {\n\n    /**\n     * The line grouped content of a text file.\n     */\n    value: ReadableStream<string>;\n}\n\nexport interface CreateTextFileOptions extends WriteEncodingOptions, CreateFileOptions { }\n\nexport interface WriteTextFileOptions extends WriteEncodingOptions, WriteFileOptions { }\n\nexport interface UpdateTextFileOptions extends WriteEncodingOptions, WriteFileOptions {\n    readEncoding: string\n}\n\nexport interface UserFileOperationEvent extends WaitUntilEvent {\n\n    /**\n     * An identifier to correlate the operation through the\n     * different event types (before, after, error).\n     */\n    readonly correlationId: number;\n\n    /**\n     * The file operation that is taking place.\n     */\n    readonly operation: FileOperation;\n\n    /**\n     * The resource the event is about.\n     */\n    readonly target: URI;\n\n    /**\n     * A property that is defined for move operations.\n     */\n    readonly source?: URI;\n}\n\nexport const FileServiceContribution = Symbol('FileServiceContribution');\n\n/**\n * A {@link FileServiceContribution} can be used to add custom {@link FileSystemProvider}s.\n * For this, the contribution has to listen to the {@link FileSystemProviderActivationEvent} and register\n * the custom {@link FileSystemProvider}s according to the scheme when this event is fired.\n *\n * ### Example usage\n * ```ts\n * export class MyFileServiceContribution implements FileServiceContribution {\n *     registerFileSystemProviders(service: FileService): void {\n *         service.onWillActivateFileSystemProvider(event => {\n *             if (event.scheme === 'mySyncProviderScheme') {\n *                 service.registerProvider('mySyncProviderScheme', this.mySyncProvider);\n *             }\n *             if (event.scheme === 'myAsyncProviderScheme') {\n *                 event.waitUntil((async () => {\n *                     const myAsyncProvider = await this.createAsyncProvider();\n *                     service.registerProvider('myAsyncProviderScheme', myAsyncProvider);\n *                 })());\n *             }\n *         });\n *\n *     }\n *```\n */\nexport interface FileServiceContribution {\n    /**\n     * Register custom file system providers for the given {@link FileService}.\n     * @param service The file service for which the providers should be registered.\n     */\n    registerFileSystemProviders(service: FileService): void;\n}\n\n/**\n * Represents the `FileSystemProviderRegistration` event.\n * This event is fired by the {@link FileService} if a {@link FileSystemProvider} is\n * registered to or unregistered from the service.\n */\nexport interface FileSystemProviderRegistrationEvent {\n    /** `True` if a new provider has been registered, `false` if a provider has been unregistered. */\n    added: boolean;\n    /** The (uri) scheme for which the provider was (previously) registered */\n    scheme: string;\n    /** The affected file system provider for which this event was fired. */\n    provider?: FileSystemProvider;\n}\n\n/**\n * Represents the `FileSystemProviderCapabilitiesChange` event.\n * This event is fired by the {@link FileService} if the capabilities of one of its managed\n * {@link FileSystemProvider}s have changed.\n */\nexport interface FileSystemProviderCapabilitiesChangeEvent {\n    /** The affected file system provider for which this event was fired. */\n    provider: FileSystemProvider;\n    /** The (uri) scheme for which the provider is registered */\n    scheme: string;\n}\n\n/**\n * Represents the `FileSystemProviderActivation` event.\n * This event is fired by the {@link FileService} if it wants to activate the\n * {@link FileSystemProvider} for a specific scheme.\n */\nexport interface FileSystemProviderActivationEvent extends WaitUntilEvent {\n    /** The (uri) scheme for which the provider should be activated */\n    scheme: string;\n}\n\nexport const enum TextFileOperationResult {\n    FILE_IS_BINARY\n}\n\nexport class TextFileOperationError extends FileOperationError {\n\n    constructor(\n        message: string,\n        public textFileOperationResult: TextFileOperationResult,\n        override options?: ReadTextFileOptions & WriteTextFileOptions\n    ) {\n        super(message, FileOperationResult.FILE_OTHER_ERROR);\n        Object.setPrototypeOf(this, TextFileOperationError.prototype);\n    }\n\n}\n\n/**\n * The {@link FileService} is the common facade responsible for all interactions with file systems.\n * It manages all registered {@link FileSystemProvider}s and\n *  forwards calls to the responsible {@link FileSystemProvider}, determined by the scheme.\n * For additional documentation regarding the provided functions see also {@link FileSystemProvider}.\n */\n@injectable()\nexport class FileService {\n\n    private readonly BUFFER_SIZE = 64 * 1024;\n\n    @inject(LabelProvider)\n    protected readonly labelProvider: LabelProvider;\n\n    @inject(FileSystemPreferences)\n    protected readonly preferences: FileSystemPreferences;\n\n    @inject(ProgressService)\n    protected readonly progressService: ProgressService;\n\n    @inject(EncodingRegistry)\n    protected readonly encodingRegistry: EncodingRegistry;\n\n    @inject(EncodingService)\n    protected readonly encodingService: EncodingService;\n\n    @inject(ContributionProvider) @named(FileServiceContribution)\n    protected readonly contributions: ContributionProvider<FileServiceContribution>;\n\n    @inject(FileSystemWatcherErrorHandler)\n    protected readonly watcherErrorHandler: FileSystemWatcherErrorHandler;\n\n    @postConstruct()\n    protected init(): void {\n        for (const contribution of this.contributions.getContributions()) {\n            contribution.registerFileSystemProviders(this);\n        }\n    }\n\n    // #region Events\n\n    private correlationIds = 0;\n\n    private readonly onWillRunUserOperationEmitter = new AsyncEmitter<UserFileOperationEvent>();\n    /**\n     * An event that is emitted when file operation is being performed.\n     * This event is triggered by user gestures.\n     */\n    readonly onWillRunUserOperation = this.onWillRunUserOperationEmitter.event;\n\n    private readonly onDidFailUserOperationEmitter = new AsyncEmitter<UserFileOperationEvent>();\n    /**\n     * An event that is emitted when file operation is failed.\n     * This event is triggered by user gestures.\n     */\n    readonly onDidFailUserOperation = this.onDidFailUserOperationEmitter.event;\n\n    private readonly onDidRunUserOperationEmitter = new AsyncEmitter<UserFileOperationEvent>();\n    /**\n     * An event that is emitted when file operation is finished.\n     * This event is triggered by user gestures.\n     */\n    readonly onDidRunUserOperation = this.onDidRunUserOperationEmitter.event;\n\n    // #endregion\n\n    // #region File System Provider\n\n    private onDidChangeFileSystemProviderRegistrationsEmitter = new Emitter<FileSystemProviderRegistrationEvent>();\n    readonly onDidChangeFileSystemProviderRegistrations = this.onDidChangeFileSystemProviderRegistrationsEmitter.event;\n\n    private onWillActivateFileSystemProviderEmitter = new Emitter<FileSystemProviderActivationEvent>();\n    /**\n     * See `FileServiceContribution.registerProviders`.\n     */\n    readonly onWillActivateFileSystemProvider = this.onWillActivateFileSystemProviderEmitter.event;\n\n    private onDidChangeFileSystemProviderCapabilitiesEmitter = new Emitter<FileSystemProviderCapabilitiesChangeEvent>();\n    readonly onDidChangeFileSystemProviderCapabilities = this.onDidChangeFileSystemProviderCapabilitiesEmitter.event;\n\n    private readonly providers = new Map<string, FileSystemProvider>();\n    private readonly activations = new Map<string, Promise<FileSystemProvider>>();\n\n    /**\n     * Registers a new {@link FileSystemProvider} for the given scheme.\n     * @param scheme The (uri) scheme for which the provider should be registered.\n     * @param provider The file system provider that should be registered.\n     *\n     * @returns A `Disposable` that can be invoked to unregister the given provider.\n     */\n    registerProvider(scheme: string, provider: FileSystemProvider): Disposable {\n        if (this.providers.has(scheme)) {\n            throw new Error(`A filesystem provider for the scheme '${scheme}' is already registered.`);\n        }\n\n        this.providers.set(scheme, provider);\n        this.onDidChangeFileSystemProviderRegistrationsEmitter.fire({ added: true, scheme, provider });\n\n        const providerDisposables = new DisposableCollection();\n        providerDisposables.push(provider.onDidChangeFile(changes => this.onDidFilesChangeEmitter.fire(new FileChangesEvent(changes))));\n        providerDisposables.push(provider.onFileWatchError(() => this.handleFileWatchError()));\n        providerDisposables.push(provider.onDidChangeCapabilities(() => this.onDidChangeFileSystemProviderCapabilitiesEmitter.fire({ provider, scheme })));\n\n        return Disposable.create(() => {\n            this.onDidChangeFileSystemProviderRegistrationsEmitter.fire({ added: false, scheme, provider });\n            this.providers.delete(scheme);\n\n            providerDisposables.dispose();\n        });\n    }\n\n    /**\n     * Try to activate the registered provider for the given scheme\n     * @param scheme  The uri scheme for which the responsible provider should be activated.\n     *\n     * @returns A promise of the activated file system provider. Only resolves if a provider is available for this scheme, gets rejected otherwise.\n     */\n    async activateProvider(scheme: string): Promise<FileSystemProvider> {\n        let provider = this.providers.get(scheme);\n        if (provider) {\n            return provider;\n        }\n        let activation = this.activations.get(scheme);\n        if (!activation) {\n            const deferredActivation = new Deferred<FileSystemProvider>();\n            this.activations.set(scheme, activation = deferredActivation.promise);\n            WaitUntilEvent.fire(this.onWillActivateFileSystemProviderEmitter, { scheme }).then(() => {\n                provider = this.providers.get(scheme);\n                if (!provider) {\n                    const error = new Error();\n                    error.name = 'ENOPRO';\n                    error.message = `No file system provider found for scheme ${scheme}`;\n                    throw error;\n                } else {\n                    deferredActivation.resolve(provider);\n                }\n            }).catch(e => deferredActivation.reject(e));\n        }\n        return activation;\n    }\n\n    /**\n     * Tests if the service (i.e. any of its registered {@link FileSystemProvider}s) can handle the given resource.\n     * @param resource `URI` of the resource to test.\n     *\n     * @returns `true` if the resource can be handled, `false` otherwise.\n     */\n    canHandleResource(resource: URI): boolean {\n        return this.providers.has(resource.scheme);\n    }\n\n    /**\n     * Tests if the service (i.e the {@link FileSystemProvider} registered for the given uri scheme) provides the given capability.\n     * @param resource `URI` of the resource to test.\n     * @param capability The required capability.\n     *\n     * @returns `true` if the resource can be handled and the required capability can be provided.\n     */\n    hasCapability(resource: URI, capability: FileSystemProviderCapabilities): boolean {\n        const provider = this.providers.get(resource.scheme);\n\n        return !!(provider && (provider.capabilities & capability));\n    }\n\n    /**\n     * List the schemes and capabilities for registered file system providers\n     */\n    listCapabilities(): { scheme: string; capabilities: FileSystemProviderCapabilities }[] {\n        return Array.from(this.providers.entries()).map(([scheme, provider]) => ({\n            scheme,\n            capabilities: provider.capabilities\n        }));\n    }\n\n    protected async withProvider(resource: URI): Promise<FileSystemProvider> {\n        // Assert path is absolute\n        if (!resource.path.isAbsolute) {\n            throw new FileOperationError(nls.localizeByDefault(\"Unable to resolve filesystem provider with relative file path '{0}'\", this.resourceForError(resource)), FileOperationResult.FILE_INVALID_PATH);\n        }\n\n        return this.activateProvider(resource.scheme);\n    }\n\n    private async withReadProvider(resource: URI): Promise<FileSystemProviderWithFileReadWriteCapability | FileSystemProviderWithOpenReadWriteCloseCapability> {\n        const provider = await this.withProvider(resource);\n\n        if (hasOpenReadWriteCloseCapability(provider) || hasReadWriteCapability(provider)) {\n            return provider;\n        }\n\n        throw new Error(`Filesystem provider for scheme '${resource.scheme}' neither has FileReadWrite, FileReadStream nor FileOpenReadWriteClose capability which is needed for the read operation.`);\n    }\n\n    private async withWriteProvider(resource: URI): Promise<FileSystemProviderWithFileReadWriteCapability | FileSystemProviderWithOpenReadWriteCloseCapability> {\n        const provider = await this.withProvider(resource);\n        if (hasOpenReadWriteCloseCapability(provider) || hasReadWriteCapability(provider)) {\n            return provider;\n        }\n\n        throw new Error(`Filesystem provider for scheme '${resource.scheme}' neither has FileReadWrite nor FileOpenReadWriteClose capability which is needed for the write operation.`);\n    }\n\n    // #endregion\n\n    private onDidRunOperationEmitter = new Emitter<FileOperationEvent>();\n    /**\n     * An event that is emitted when operation is finished.\n     * This event is triggered by user gestures and programmatically.\n     */\n    readonly onDidRunOperation = this.onDidRunOperationEmitter.event;\n\n    /**\n     * Try to resolve file information and metadata for the given resource.\n     * @param resource `URI` of the resource that should be resolved.\n     * @param options  Options to customize the resolvement process.\n     *\n     * @return A promise that resolves if the resource could be successfully resolved.\n     */\n    resolve(resource: URI, options: ResolveMetadataFileOptions): Promise<FileStatWithMetadata>;\n    resolve(resource: URI, options?: ResolveFileOptions | undefined): Promise<FileStat>;\n    async resolve(resource: any, options?: any) {\n        try {\n            return await this.doResolveFile(resource, options);\n        } catch (error) {\n\n            // Specially handle file not found case as file operation result\n            if (toFileSystemProviderErrorCode(error) === FileSystemProviderErrorCode.FileNotFound) {\n                throw new FileOperationError(nls.localizeByDefault(\"Unable to resolve nonexistent file '{0}'\", this.resourceForError(resource)), FileOperationResult.FILE_NOT_FOUND);\n            }\n\n            // Bubble up any other error as is\n            throw ensureFileSystemProviderError(error);\n        }\n    }\n\n    private async doResolveFile(resource: URI, options: ResolveMetadataFileOptions): Promise<FileStatWithMetadata>;\n    private async doResolveFile(resource: URI, options?: ResolveFileOptions): Promise<FileStat>;\n    private async doResolveFile(resource: URI, options?: ResolveFileOptions): Promise<FileStat> {\n        const provider = await this.withProvider(resource);\n\n        const resolveTo = options?.resolveTo;\n        const resolveSingleChildDescendants = options?.resolveSingleChildDescendants;\n        const resolveMetadata = options?.resolveMetadata;\n\n        const stat = await provider.stat(resource);\n\n        let trie: TernarySearchTree<URI, boolean> | undefined;\n\n        return this.toFileStat(provider, resource, stat, undefined, !!resolveMetadata, (stat, siblings) => {\n\n            // lazy trie to check for recursive resolving\n            if (!trie) {\n                trie = TernarySearchTree.forUris<true>(!!(provider.capabilities & FileSystemProviderCapabilities.PathCaseSensitive));\n                trie.set(resource, true);\n                if (Array.isArray(resolveTo) && resolveTo.length) {\n                    resolveTo.forEach(uri => trie!.set(uri, true));\n                }\n            }\n\n            // check for recursive resolving\n            if (Boolean(trie.findSuperstr(stat.resource) || trie.get(stat.resource))) {\n                return true;\n            }\n\n            // check for resolving single child folders\n            if (stat.isDirectory && resolveSingleChildDescendants) {\n                return siblings === 1;\n            }\n\n            return false;\n        });\n    }\n\n    private async toFileStat(provider: FileSystemProvider, resource: URI, stat: Stat | { type: FileType } & Partial<Stat>, siblings: number | undefined, resolveMetadata: boolean, recurse: (stat: FileStat, siblings?: number) => boolean): Promise<FileStat>;\n    private async toFileStat(provider: FileSystemProvider, resource: URI, stat: Stat, siblings: number | undefined, resolveMetadata: true, recurse: (stat: FileStat, siblings?: number) => boolean): Promise<FileStatWithMetadata>;\n    private async toFileStat(provider: FileSystemProvider, resource: URI, stat: Stat | { type: FileType } & Partial<Stat>, siblings: number | undefined, resolveMetadata: boolean, recurse: (stat: FileStat, siblings?: number) => boolean): Promise<FileStat> {\n        const fileStat = FileStat.fromStat(resource, stat);\n\n        // check to recurse for directories\n        if (fileStat.isDirectory && recurse(fileStat, siblings)) {\n            try {\n                const entries = await provider.readdir(resource);\n                const resolvedEntries = await Promise.all(entries.map(async ([name, type]) => {\n                    try {\n                        const childResource = resource.resolve(name);\n                        const childStat = resolveMetadata ? await provider.stat(childResource) : { type };\n\n                        return await this.toFileStat(provider, childResource, childStat, entries.length, resolveMetadata, recurse);\n                    } catch (error) {\n                        console.trace(error);\n\n                        return null; // can happen e.g. due to permission errors\n                    }\n                }));\n\n                // make sure to get rid of null values that signal a failure to resolve a particular entry\n                fileStat.children = resolvedEntries.filter(e => !!e) as FileStat[];\n            } catch (error) {\n                console.trace(error);\n\n                fileStat.children = []; // gracefully handle errors, we may not have permissions to read\n            }\n\n            return fileStat;\n        }\n\n        return fileStat;\n    }\n\n    /**\n     * Try to resolve file information and metadata for all given resource.\n     * @param toResolve An array of all the resources (and corresponding resolvement options) that should be resolved.\n     *\n     * @returns A promise of all resolved resources. The promise is not rejected if any of the given resources cannot be resolved.\n     * Instead this is reflected with the `success` flag of the corresponding {@link ResolveFileResult}.\n     */\n    async resolveAll(toResolve: { resource: URI, options?: ResolveFileOptions }[]): Promise<ResolveFileResult[]>;\n    async resolveAll(toResolve: { resource: URI, options: ResolveMetadataFileOptions }[]): Promise<ResolveFileResultWithMetadata[]>;\n    async resolveAll(toResolve: { resource: URI; options?: ResolveFileOptions; }[]): Promise<ResolveFileResult[]> {\n        return Promise.all(toResolve.map(async entry => {\n            try {\n                return { stat: await this.doResolveFile(entry.resource, entry.options), success: true };\n            } catch (error) {\n                console.trace(error);\n\n                return { stat: undefined, success: false };\n            }\n        }));\n    }\n\n    /**\n     * Tests if the given resource exists in the filesystem.\n     * @param resource `URI` of the resource which should be tested.\n     * @throws Will throw an error if no {@link FileSystemProvider} is registered for the given resource.\n     *\n     * @returns A promise that resolves to `true` if the resource exists.\n     */\n    async exists(resource: URI): Promise<boolean> {\n        const provider = await this.withProvider(resource);\n\n        try {\n            const stat = await provider.stat(resource);\n\n            return !!stat;\n        } catch (error) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests a user's permissions for the given resource.\n     * @param resource `URI` of the resource which should be tested.\n     * @param mode An optional integer that specifies the accessibility checks to be performed.\n     *      Check `FileAccess.Constants` for possible values of mode.\n     *      It is possible to create a mask consisting of the bitwise `OR` of two or more values (e.g. FileAccess.Constants.W_OK | FileAccess.Constants.R_OK).\n     *      If `mode` is not defined, `FileAccess.Constants.F_OK` will be used instead.\n     */\n    async access(resource: URI, mode?: number): Promise<boolean> {\n        const provider = await this.withProvider(resource);\n\n        if (!hasAccessCapability(provider)) {\n            return false;\n        }\n        try {\n            await provider.access(resource, mode);\n            return true;\n        } catch (error) {\n            return false;\n        }\n    }\n\n    /**\n     * Resolves the fs path of the given URI.\n     *\n     * USE WITH CAUTION: You should always prefer URIs to paths if possible, as they are\n     * portable and platform independent. Paths should only be used in cases you directly\n     * interact with the OS, e.g. when running a command on the shell.\n     *\n     * If you need to display human readable simple or long names then use `LabelProvider` instead.\n     * @param resource `URI` of the resource that should be resolved.\n     * @throws Will throw an error if no {@link FileSystemProvider} is registered for the given resource.\n     *\n     * @returns A promise of the resolved fs path.\n     */\n    async fsPath(resource: URI): Promise<string> {\n        const provider = await this.withProvider(resource);\n\n        if (!hasAccessCapability(provider)) {\n            return resource.path.toString();\n        }\n        return provider.fsPath(resource);\n    }\n\n    // #region Text File Reading/Writing\n\n    async create(resource: URI, value?: string | Readable<string>, options?: CreateTextFileOptions): Promise<FileStatWithMetadata> {\n        if (options?.fromUserGesture === false) {\n            return this.doCreate(resource, value, options);\n        }\n        await this.runFileOperationParticipants(resource, undefined, FileOperation.CREATE);\n\n        const event = { correlationId: this.correlationIds++, operation: FileOperation.CREATE, target: resource };\n        await this.onWillRunUserOperationEmitter.fire(event);\n\n        let stat: FileStatWithMetadata;\n        try {\n            stat = await this.doCreate(resource, value, options);\n        } catch (error) {\n            await this.onDidFailUserOperationEmitter.fire(event);\n            throw error;\n        }\n\n        await this.onDidRunUserOperationEmitter.fire(event);\n\n        return stat;\n    }\n\n    protected async doCreate(resource: URI, value?: string | Readable<string>, options?: CreateTextFileOptions): Promise<FileStatWithMetadata> {\n        const encoding = await this.getWriteEncoding(resource, options);\n        const encoded = await this.encodingService.encodeStream(value, encoding);\n        return this.createFile(resource, encoded, options);\n    }\n\n    async write(resource: URI, value: string | Readable<string>, options?: WriteTextFileOptions): Promise<FileStatWithMetadata & { encoding: string }> {\n        const encoding = await this.getWriteEncoding(resource, options);\n        const encoded = await this.encodingService.encodeStream(value, encoding);\n        return Object.assign(await this.writeFile(resource, encoded, options), { encoding: encoding.encoding });\n    }\n\n    async read(resource: URI, options?: ReadTextFileOptions): Promise<TextFileContent> {\n        const [bufferStream, decoder] = await this.doRead(resource, {\n            ...options,\n            // optimization: since we know that the caller does not\n            // care about buffering, we indicate this to the reader.\n            // this reduces all the overhead the buffered reading\n            // has (open, read, close) if the provider supports\n            // unbuffered reading.\n            preferUnbuffered: true\n        });\n\n        return {\n            ...bufferStream,\n            encoding: decoder.detected.encoding || UTF8,\n            value: await consumeStream(decoder.stream, strings => strings.join(''))\n        };\n    }\n\n    async readStream(resource: URI, options?: ReadTextFileOptions): Promise<TextFileStreamContent> {\n        const [bufferStream, decoder] = await this.doRead(resource, options);\n\n        return {\n            ...bufferStream,\n            encoding: decoder.detected.encoding || UTF8,\n            value: decoder.stream\n        };\n    }\n\n    private async doRead(resource: URI, options?: ReadTextFileOptions & { preferUnbuffered?: boolean }): Promise<[FileStreamContent, DecodeStreamResult]> {\n        options = this.resolveReadOptions(options);\n\n        // read stream raw (either buffered or unbuffered)\n        let bufferStream: FileStreamContent;\n        if (options?.preferUnbuffered) {\n            const content = await this.readFile(resource, options);\n            bufferStream = {\n                ...content,\n                value: BinaryBufferReadableStream.fromBuffer(content.value)\n            };\n        } else {\n            bufferStream = await this.readFileStream(resource, options);\n        }\n\n        const decoder = await this.encodingService.decodeStream(bufferStream.value, {\n            guessEncoding: options.autoGuessEncoding,\n            overwriteEncoding: detectedEncoding => this.getReadEncoding(resource, options, detectedEncoding)\n        });\n\n        // validate binary\n        if (options?.acceptTextOnly && decoder.detected.seemsBinary) {\n            throw new TextFileOperationError(nls.localizeByDefault('File seems to be binary and cannot be opened as text'), TextFileOperationResult.FILE_IS_BINARY, options);\n        }\n\n        return [bufferStream, decoder];\n    }\n\n    protected resolveReadOptions(options?: ReadTextFileOptions): ReadTextFileOptions {\n        options = {\n            ...options,\n            autoGuessEncoding: typeof options?.autoGuessEncoding === 'boolean' ? options.autoGuessEncoding : this.preferences['files.autoGuessEncoding']\n        };\n        const limits: Mutable<ReadTextFileOptions['limits']> = options.limits = options.limits || {};\n        if (typeof limits.size !== 'number') {\n            limits.size = this.preferences['files.maxFileSizeMB'] * 1024 * 1024;\n        }\n        return options;\n    }\n\n    async update(resource: URI, changes: TextDocumentContentChangeEvent[], options: UpdateTextFileOptions): Promise<FileStatWithMetadata & { encoding: string }> {\n        const provider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(resource), resource);\n        try {\n            await this.validateWriteFile(provider, resource, options);\n            if (hasUpdateCapability(provider)) {\n                const encoding = await this.getEncodingForResource(resource, options ? options.encoding : undefined);;\n                const stat = await provider.updateFile(resource, changes, {\n                    readEncoding: options.readEncoding,\n                    writeEncoding: encoding,\n                    overwriteEncoding: options.overwriteEncoding || false\n                });\n                return Object.assign(FileStat.fromStat(resource, stat), { encoding: stat.encoding });\n            } else {\n                throw new Error('incremental file update is not supported');\n            }\n        } catch (error) {\n            this.rethrowAsFileOperationError(\"Unable to write file '{0}' ({1})\", resource, error, options);\n        }\n    }\n\n    // #endregion\n\n    // #region File Reading/Writing\n\n    async createFile(resource: URI, bufferOrReadableOrStream: BinaryBuffer | BinaryBufferReadable | BinaryBufferReadableStream = BinaryBuffer.fromString(''), options?: CreateFileOptions): Promise<FileStatWithMetadata> {\n\n        // validate overwrite\n        if (!options?.overwrite && await this.exists(resource)) {\n            throw new FileOperationError(nls.localizeByDefault(\"Unable to create file '{0}' that already exists when overwrite flag is not set\", this.resourceForError(resource)), FileOperationResult.FILE_MODIFIED_SINCE, options);\n        }\n\n        // do write into file (this will create it too)\n        const fileStat = await this.writeFile(resource, bufferOrReadableOrStream);\n\n        // events\n        this.onDidRunOperationEmitter.fire(new FileOperationEvent(resource, FileOperation.CREATE, fileStat));\n\n        return fileStat;\n    }\n\n    async writeFile(resource: URI, bufferOrReadableOrStream: BinaryBuffer | BinaryBufferReadable | BinaryBufferReadableStream, options?: WriteFileOptions): Promise<FileStatWithMetadata> {\n        const provider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(resource), resource);\n\n        try {\n\n            // validate write\n            const stat = await this.validateWriteFile(provider, resource, options);\n\n            // mkdir recursively as needed\n            if (!stat) {\n                await this.mkdirp(provider, resource.parent);\n            }\n\n            // optimization: if the provider has unbuffered write capability and the data\n            // to write is a Readable, we consume up to 3 chunks and try to write the data\n            // unbuffered to reduce the overhead. If the Readable has more data to provide\n            // we continue to write buffered.\n            let bufferOrReadableOrStreamOrBufferedStream: BinaryBuffer | BinaryBufferReadable | BinaryBufferReadableStream | BinaryBufferReadableBufferedStream;\n            if (hasReadWriteCapability(provider) && !(bufferOrReadableOrStream instanceof BinaryBuffer)) {\n                if (isReadableStream(bufferOrReadableOrStream)) {\n                    const bufferedStream = await peekStream(bufferOrReadableOrStream, 3);\n                    if (bufferedStream.ended) {\n                        bufferOrReadableOrStreamOrBufferedStream = BinaryBuffer.concat(bufferedStream.buffer);\n                    } else {\n                        bufferOrReadableOrStreamOrBufferedStream = bufferedStream;\n                    }\n                } else {\n                    bufferOrReadableOrStreamOrBufferedStream = peekReadable(bufferOrReadableOrStream, data => BinaryBuffer.concat(data), 3);\n                }\n            } else {\n                bufferOrReadableOrStreamOrBufferedStream = bufferOrReadableOrStream;\n            }\n\n            // write file: unbuffered (only if data to write is a buffer, or the provider has no buffered write capability)\n            if (!hasOpenReadWriteCloseCapability(provider) || (hasReadWriteCapability(provider) && bufferOrReadableOrStreamOrBufferedStream instanceof BinaryBuffer)) {\n                await this.doWriteUnbuffered(provider, resource, bufferOrReadableOrStreamOrBufferedStream);\n            }\n\n            // write file: buffered\n            else {\n                await this.doWriteBuffered(provider, resource, bufferOrReadableOrStreamOrBufferedStream instanceof BinaryBuffer ? BinaryBufferReadable.fromBuffer(bufferOrReadableOrStreamOrBufferedStream) : bufferOrReadableOrStreamOrBufferedStream);\n            }\n        } catch (error) {\n            this.rethrowAsFileOperationError(\"Unable to write file '{0}' ({1})\", resource, error, options);\n        }\n\n        return this.resolve(resource, { resolveMetadata: true });\n    }\n\n    private async validateWriteFile(provider: FileSystemProvider, resource: URI, options?: WriteFileOptions): Promise<Stat | undefined> {\n        let stat: Stat | undefined = undefined;\n        try {\n            stat = await provider.stat(resource);\n        } catch (error) {\n            return undefined; // file might not exist\n        }\n\n        // file cannot be directory\n        if ((stat.type & FileType.Directory) !== 0) {\n            throw new FileOperationError(nls.localizeByDefault(\"Unable to write file '{0}' that is actually a directory\", this.resourceForError(resource)), FileOperationResult.FILE_IS_DIRECTORY, options);\n        }\n\n        if (this.modifiedSince(stat, options)) {\n            throw new FileOperationError(nls.localizeByDefault('File Modified Since'), FileOperationResult.FILE_MODIFIED_SINCE, options);\n        }\n\n        return stat;\n    }\n\n    /**\n     * Dirty write prevention: if the file on disk has been changed and does not match our expected\n     * mtime and etag, we bail out to prevent dirty writing.\n     *\n     * First, we check for a mtime that is in the future before we do more checks. The assumption is\n     * that only the mtime is an indicator for a file that has changed on disk.\n     *\n     * Second, if the mtime has advanced, we compare the size of the file on disk with our previous\n     * one using the etag() function. Relying only on the mtime check has proven to produce false\n     * positives due to file system weirdness (especially around remote file systems). As such, the\n     * check for size is a weaker check because it can return a false negative if the file has changed\n     * but to the same length. This is a compromise we take to avoid having to produce checksums of\n     * the file content for comparison which would be much slower to compute.\n     */\n    protected modifiedSince(stat: Stat, options?: WriteFileOptions): boolean {\n        return !!options && typeof options.mtime === 'number' && typeof options.etag === 'string' && options.etag !== ETAG_DISABLED &&\n            typeof stat.mtime === 'number' && typeof stat.size === 'number' &&\n            options.mtime < stat.mtime && options.etag !== etag({ mtime: options.mtime /* not using stat.mtime for a reason, see above */, size: stat.size });\n    }\n\n    async readFile(resource: URI, options?: ReadFileOptions): Promise<FileContent> {\n        const provider = await this.withReadProvider(resource);\n\n        const stream = await this.doReadAsFileStream(provider, resource, {\n            ...options,\n            // optimization: since we know that the caller does not\n            // care about buffering, we indicate this to the reader.\n            // this reduces all the overhead the buffered reading\n            // has (open, read, close) if the provider supports\n            // unbuffered reading.\n            preferUnbuffered: true\n        });\n\n        return {\n            ...stream,\n            value: await BinaryBufferReadableStream.toBuffer(stream.value)\n        };\n    }\n\n    async readFileStream(resource: URI, options?: ReadFileOptions): Promise<FileStreamContent> {\n        const provider = await this.withReadProvider(resource);\n\n        return this.doReadAsFileStream(provider, resource, options);\n    }\n\n    private async doReadAsFileStream(provider: FileSystemProviderWithFileReadWriteCapability | FileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, options?: ReadFileOptions & { preferUnbuffered?: boolean }): Promise<FileStreamContent> {\n\n        // install a cancellation token that gets cancelled\n        // when any error occurs. this allows us to resolve\n        // the content of the file while resolving metadata\n        // but still cancel the operation in certain cases.\n        const cancellableSource = new CancellationTokenSource();\n\n        // validate read operation\n        const statPromise = this.validateReadFile(resource, options).then(stat => stat, error => {\n            cancellableSource.cancel();\n\n            throw error;\n        });\n\n        try {\n\n            // if the etag is provided, we await the result of the validation\n            // due to the likelyhood of hitting a NOT_MODIFIED_SINCE result.\n            // otherwise, we let it run in parallel to the file reading for\n            // optimal startup performance.\n            if (options && typeof options.etag === 'string' && options.etag !== ETAG_DISABLED) {\n                await statPromise;\n            }\n\n            let fileStreamPromise: Promise<BinaryBufferReadableStream>;\n\n            // read unbuffered (only if either preferred, or the provider has no buffered read capability)\n            if (!(hasOpenReadWriteCloseCapability(provider) || hasFileReadStreamCapability(provider)) || (hasReadWriteCapability(provider) && options?.preferUnbuffered)) {\n                fileStreamPromise = this.readFileUnbuffered(provider, resource, options);\n            }\n\n            // read streamed (always prefer over primitive buffered read)\n            else if (hasFileReadStreamCapability(provider)) {\n                fileStreamPromise = Promise.resolve(this.readFileStreamed(provider, resource, cancellableSource.token, options));\n            }\n\n            // read buffered\n            else {\n                fileStreamPromise = Promise.resolve(this.readFileBuffered(provider, resource, cancellableSource.token, options));\n            }\n\n            const [fileStat, fileStream] = await Promise.all([statPromise, fileStreamPromise]);\n\n            return {\n                ...fileStat,\n                value: fileStream\n            };\n        } catch (error) {\n            this.rethrowAsFileOperationError(\"Unable to read file '{0}' ({1})\", resource, error, options);\n        }\n    }\n\n    private readFileStreamed(provider: FileSystemProviderWithFileReadStreamCapability, resource: URI, token: CancellationToken, options: ReadFileOptions = Object.create(null)): BinaryBufferReadableStream {\n        const fileStream = provider.readFileStream(resource, options, token);\n\n        return transform(fileStream, {\n            data: data => data instanceof BinaryBuffer ? data : BinaryBuffer.wrap(data),\n            error: error => this.asFileOperationError(\"Unable to read file '{0}' ({1})\", resource, error, options)\n        }, data => BinaryBuffer.concat(data));\n    }\n\n    private readFileBuffered(provider: FileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, token: CancellationToken, options: ReadFileOptions = Object.create(null)): BinaryBufferReadableStream {\n        const stream = BinaryBufferWriteableStream.create();\n\n        readFileIntoStream(provider, resource, stream, data => data, {\n            ...options,\n            bufferSize: this.BUFFER_SIZE,\n            errorTransformer: error => this.asFileOperationError(\"Unable to read file '{0}' ({1})\", resource, error, options)\n        }, token);\n\n        return stream;\n    }\n\n    protected rethrowAsFileOperationError(message: string, resource: URI, error: Error, options?: ReadFileOptions & WriteFileOptions & CreateFileOptions): never {\n        throw this.asFileOperationError(message, resource, error, options);\n    }\n    protected asFileOperationError(message: string, resource: URI, error: Error, options?: ReadFileOptions & WriteFileOptions & CreateFileOptions): FileOperationError {\n        const fileOperationError = new FileOperationError(nls.localizeByDefault(message, this.resourceForError(resource), ensureFileSystemProviderError(error).toString()),\n            toFileOperationResult(error), options);\n        fileOperationError.stack = `${fileOperationError.stack}\\nCaused by: ${error.stack}`;\n        return fileOperationError;\n    }\n\n    private async readFileUnbuffered(provider: FileSystemProviderWithFileReadWriteCapability, resource: URI, options?: ReadFileOptions): Promise<BinaryBufferReadableStream> {\n        let buffer = await provider.readFile(resource);\n\n        // respect position option\n        if (options && typeof options.position === 'number') {\n            buffer = buffer.slice(options.position);\n        }\n\n        // respect length option\n        if (options && typeof options.length === 'number') {\n            buffer = buffer.slice(0, options.length);\n        }\n\n        // Throw if file is too large to load\n        this.validateReadFileLimits(resource, buffer.byteLength, options);\n\n        return BinaryBufferReadableStream.fromBuffer(BinaryBuffer.wrap(buffer));\n    }\n\n    private async validateReadFile(resource: URI, options?: ReadFileOptions): Promise<FileStatWithMetadata> {\n        const stat = await this.resolve(resource, { resolveMetadata: true });\n\n        // Throw if resource is a directory\n        if (stat.isDirectory) {\n            throw new FileOperationError(nls.localizeByDefault(\"Unable to read file '{0}' that is actually a directory\", this.resourceForError(resource)), FileOperationResult.FILE_IS_DIRECTORY, options);\n        }\n\n        // Throw if file not modified since (unless disabled)\n        if (options && typeof options.etag === 'string' && options.etag !== ETAG_DISABLED && options.etag === stat.etag) {\n            throw new FileOperationError(nls.localizeByDefault('File not modified since'), FileOperationResult.FILE_NOT_MODIFIED_SINCE, options);\n        }\n\n        // Throw if file is too large to load\n        this.validateReadFileLimits(resource, stat.size, options);\n\n        return stat;\n    }\n\n    private validateReadFileLimits(resource: URI, size: number, options?: ReadFileOptions): void {\n        if (options?.limits) {\n            let tooLargeErrorResult: FileOperationResult | undefined = undefined;\n\n            if (typeof options.limits.memory === 'number' && size > options.limits.memory) {\n                tooLargeErrorResult = FileOperationResult.FILE_EXCEEDS_MEMORY_LIMIT;\n            }\n\n            if (typeof options.limits.size === 'number' && size > options.limits.size) {\n                tooLargeErrorResult = FileOperationResult.FILE_TOO_LARGE;\n            }\n\n            if (typeof tooLargeErrorResult === 'number') {\n                throw new FileOperationError(nls.localizeByDefault(\"Unable to read file '{0}' that is too large to open\", this.resourceForError(resource)), tooLargeErrorResult);\n            }\n        }\n    }\n\n    // #endregion\n\n    // #region Move/Copy/Delete/Create Folder\n\n    async move(source: URI, target: URI, options?: MoveFileOptions): Promise<FileStatWithMetadata> {\n        if (options?.fromUserGesture === false) {\n            return this.doMove(source, target, options.overwrite);\n        }\n        await this.runFileOperationParticipants(target, source, FileOperation.MOVE);\n\n        const event = { correlationId: this.correlationIds++, operation: FileOperation.MOVE, target, source };\n        await this.onWillRunUserOperationEmitter.fire(event);\n        let stat: FileStatWithMetadata;\n        try {\n            stat = await this.doMove(source, target, options?.overwrite);\n        } catch (error) {\n            await this.onDidFailUserOperationEmitter.fire(event);\n            throw error;\n        }\n\n        await this.onDidRunUserOperationEmitter.fire(event);\n        return stat;\n    }\n\n    protected async doMove(source: URI, target: URI, overwrite?: boolean): Promise<FileStatWithMetadata> {\n        const sourceProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(source), source);\n        const targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\n\n        // move\n        const mode = await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'move', !!overwrite);\n\n        // resolve and send events\n        const fileStat = await this.resolve(target, { resolveMetadata: true });\n        this.onDidRunOperationEmitter.fire(new FileOperationEvent(source, mode === 'move' ? FileOperation.MOVE : FileOperation.COPY, fileStat));\n\n        return fileStat;\n    }\n\n    async copy(source: URI, target: URI, options?: CopyFileOptions): Promise<FileStatWithMetadata> {\n        if (options?.fromUserGesture === false) {\n            return this.doCopy(source, target, options.overwrite);\n        }\n        await this.runFileOperationParticipants(target, source, FileOperation.COPY);\n\n        const event = { correlationId: this.correlationIds++, operation: FileOperation.COPY, target, source };\n        await this.onWillRunUserOperationEmitter.fire(event);\n        let stat: FileStatWithMetadata;\n        try {\n            stat = await this.doCopy(source, target, options?.overwrite);\n        } catch (error) {\n            await this.onDidFailUserOperationEmitter.fire(event);\n            throw error;\n        }\n\n        await this.onDidRunUserOperationEmitter.fire(event);\n        return stat;\n    }\n\n    protected async doCopy(source: URI, target: URI, overwrite?: boolean): Promise<FileStatWithMetadata> {\n        const sourceProvider = await this.withReadProvider(source);\n        const targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\n\n        // copy\n        const mode = await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', !!overwrite);\n\n        // resolve and send events\n        const fileStat = await this.resolve(target, { resolveMetadata: true });\n        this.onDidRunOperationEmitter.fire(new FileOperationEvent(source, mode === 'copy' ? FileOperation.COPY : FileOperation.MOVE, fileStat));\n\n        return fileStat;\n    }\n\n    private async doMoveCopy(sourceProvider: FileSystemProvider, source: URI, targetProvider: FileSystemProvider, target: URI, mode: 'move' | 'copy', overwrite: boolean): Promise<'move' | 'copy'> {\n        if (source.toString() === target.toString()) {\n            return mode; // simulate node.js behaviour here and do a no-op if paths match\n        }\n\n        // validation\n        const { exists, isSameResourceWithDifferentPathCase } = await this.doValidateMoveCopy(sourceProvider, source, targetProvider, target, mode, overwrite);\n\n        // if target exists get valid target\n        if (exists && !overwrite) {\n            const parent = await this.resolve(target.parent);\n            const targetFileStat = await this.resolve(target);\n            target = FileSystemUtils.generateUniqueResourceURI(parent, target, targetFileStat.isDirectory, isSameResourceWithDifferentPathCase ? 'copy' : undefined);\n        }\n\n        // delete as needed (unless target is same resource with different path case)\n        if (exists && !isSameResourceWithDifferentPathCase && overwrite) {\n            await this.delete(target, { recursive: true });\n        }\n\n        // create parent folders\n        await this.mkdirp(targetProvider, target.parent);\n\n        // copy source => target\n        if (mode === 'copy') {\n\n            // same provider with fast copy: leverage copy() functionality\n            if (sourceProvider === targetProvider && hasFileFolderCopyCapability(sourceProvider)) {\n                await sourceProvider.copy(source, target, { overwrite });\n            }\n\n            // when copying via buffer/unbuffered, we have to manually\n            // traverse the source if it is a folder and not a file\n            else {\n                const sourceFile = await this.resolve(source);\n                if (sourceFile.isDirectory) {\n                    await this.doCopyFolder(sourceProvider, sourceFile, targetProvider, target);\n                } else {\n                    await this.doCopyFile(sourceProvider, source, targetProvider, target);\n                }\n            }\n\n            return mode;\n        }\n\n        // move source => target\n        else {\n\n            // same provider: leverage rename() functionality\n            if (sourceProvider === targetProvider) {\n                await sourceProvider.rename(source, target, { overwrite });\n\n                return mode;\n            }\n\n            // across providers: copy to target & delete at source\n            else {\n                await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', overwrite);\n\n                await this.delete(source, { recursive: true });\n\n                return 'copy';\n            }\n        }\n    }\n\n    private async doCopyFile(sourceProvider: FileSystemProvider, source: URI, targetProvider: FileSystemProvider, target: URI): Promise<void> {\n\n        // copy: source (buffered) => target (buffered)\n        if (hasOpenReadWriteCloseCapability(sourceProvider) && hasOpenReadWriteCloseCapability(targetProvider)) {\n            return this.doPipeBuffered(sourceProvider, source, targetProvider, target);\n        }\n\n        // copy: source (buffered) => target (unbuffered)\n        if (hasOpenReadWriteCloseCapability(sourceProvider) && hasReadWriteCapability(targetProvider)) {\n            return this.doPipeBufferedToUnbuffered(sourceProvider, source, targetProvider, target);\n        }\n\n        // copy: source (unbuffered) => target (buffered)\n        if (hasReadWriteCapability(sourceProvider) && hasOpenReadWriteCloseCapability(targetProvider)) {\n            return this.doPipeUnbufferedToBuffered(sourceProvider, source, targetProvider, target);\n        }\n\n        // copy: source (unbuffered) => target (unbuffered)\n        if (hasReadWriteCapability(sourceProvider) && hasReadWriteCapability(targetProvider)) {\n            return this.doPipeUnbuffered(sourceProvider, source, targetProvider, target);\n        }\n    }\n\n    private async doCopyFolder(sourceProvider: FileSystemProvider, sourceFolder: FileStat, targetProvider: FileSystemProvider, targetFolder: URI): Promise<void> {\n\n        // create folder in target\n        await targetProvider.mkdir(targetFolder);\n\n        // create children in target\n        if (Array.isArray(sourceFolder.children)) {\n            await Promise.all(sourceFolder.children.map(async sourceChild => {\n                const targetChild = targetFolder.resolve(sourceChild.name);\n                if (sourceChild.isDirectory) {\n                    return this.doCopyFolder(sourceProvider, await this.resolve(sourceChild.resource), targetProvider, targetChild);\n                } else {\n                    return this.doCopyFile(sourceProvider, sourceChild.resource, targetProvider, targetChild);\n                }\n            }));\n        }\n    }\n\n    private async doValidateMoveCopy(sourceProvider: FileSystemProvider, source: URI, targetProvider: FileSystemProvider, target: URI, mode: 'move' | 'copy', overwrite?: boolean): Promise<{ exists: boolean, isSameResourceWithDifferentPathCase: boolean }> {\n        let isSameResourceWithDifferentPathCase = false;\n\n        // Check if source is equal or parent to target (requires providers to be the same)\n        if (sourceProvider === targetProvider) {\n            const isPathCaseSensitive = !!(sourceProvider.capabilities & FileSystemProviderCapabilities.PathCaseSensitive);\n            if (!isPathCaseSensitive) {\n                isSameResourceWithDifferentPathCase = source.toString().toLowerCase() === target.toString().toLowerCase();\n            }\n\n            if (isSameResourceWithDifferentPathCase && mode === 'copy') {\n                throw new Error(nls.localizeByDefault(\"Unable to move/copy when source '{0}' is parent of target '{1}'.\", this.resourceForError(source), this.resourceForError(target)));\n            }\n\n            if (!isSameResourceWithDifferentPathCase && target.isEqualOrParent(source, isPathCaseSensitive)) {\n                throw new Error(nls.localizeByDefault(\"Unable to move/copy when source '{0}' is parent of target '{1}'.\", this.resourceForError(source), this.resourceForError(target)));\n            }\n        }\n\n        // Extra checks if target exists and this is not a rename\n        const exists = await this.exists(target);\n        if (exists && !isSameResourceWithDifferentPathCase) {\n\n            // Special case: if the target is a parent of the source, we cannot delete\n            // it as it would delete the source as well. In this case we have to throw\n            if (sourceProvider === targetProvider) {\n                const isPathCaseSensitive = !!(sourceProvider.capabilities & FileSystemProviderCapabilities.PathCaseSensitive);\n                if (source.isEqualOrParent(target, isPathCaseSensitive)) {\n                    throw new Error(nls.localizeByDefault(\"Unable to move/copy '{0}' into '{1}' since a file would replace the folder it is contained in.\", this.resourceForError(source), this.resourceForError(target)));\n                }\n            }\n        }\n\n        return { exists, isSameResourceWithDifferentPathCase };\n    }\n\n    async createFolder(resource: URI, options: FileOperationOptions = {}): Promise<FileStatWithMetadata> {\n        const {\n            fromUserGesture = true,\n        } = options;\n\n        const provider = this.throwIfFileSystemIsReadonly(await this.withProvider(resource), resource);\n\n        // mkdir recursively\n        await this.mkdirp(provider, resource);\n\n        // events\n        const fileStat = await this.resolve(resource, { resolveMetadata: true });\n\n        if (fromUserGesture) {\n            this.onDidRunUserOperationEmitter.fire({ correlationId: this.correlationIds++, operation: FileOperation.CREATE, target: resource });\n        } else {\n            this.onDidRunOperationEmitter.fire(new FileOperationEvent(resource, FileOperation.CREATE, fileStat));\n        }\n\n        return fileStat;\n    }\n\n    private async mkdirp(provider: FileSystemProvider, directory: URI): Promise<void> {\n        const directoriesToCreate: string[] = [];\n\n        // mkdir until we reach root\n        while (!directory.path.isRoot) {\n            try {\n                const stat = await provider.stat(directory);\n                if ((stat.type & FileType.Directory) === 0) {\n                    throw new Error(nls.localizeByDefault(\"Unable to create folder '{0}' that already exists but is not a directory\", this.resourceForError(directory)));\n                }\n\n                break; // we have hit a directory that exists -> good\n            } catch (error) {\n\n                // Bubble up any other error that is not file not found\n                if (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileNotFound) {\n                    throw error;\n                }\n\n                // Upon error, remember directories that need to be created\n                directoriesToCreate.push(directory.path.base);\n\n                // Continue up\n                directory = directory.parent;\n            }\n        }\n\n        // Create directories as needed\n        for (let i = directoriesToCreate.length - 1; i >= 0; i--) {\n            directory = directory.resolve(directoriesToCreate[i]);\n\n            try {\n                await provider.mkdir(directory);\n            } catch (error) {\n                if (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileExists) {\n                    // For mkdirp() we tolerate that the mkdir() call fails\n                    // in case the folder already exists. This follows node.js\n                    // own implementation of fs.mkdir({ recursive: true }) and\n                    // reduces the chances of race conditions leading to errors\n                    // if multiple calls try to create the same folders\n                    // As such, we only throw an error here if it is other than\n                    // the fact that the file already exists.\n                    // (see also https://github.com/microsoft/vscode/issues/89834)\n                    throw error;\n                }\n            }\n        }\n    }\n\n    async delete(resource: URI, options?: FileOperationOptions & Partial<FileDeleteOptions>): Promise<void> {\n        if (options?.fromUserGesture === false) {\n            return this.doDelete(resource, options);\n        }\n        await this.runFileOperationParticipants(resource, undefined, FileOperation.DELETE);\n\n        const event = { correlationId: this.correlationIds++, operation: FileOperation.DELETE, target: resource };\n        await this.onWillRunUserOperationEmitter.fire(event);\n        try {\n            await this.doDelete(resource, options);\n        } catch (error) {\n            await this.onDidFailUserOperationEmitter.fire(event);\n            throw error;\n        }\n\n        await this.onDidRunUserOperationEmitter.fire(event);\n    }\n\n    protected async doDelete(resource: URI, options?: Partial<FileDeleteOptions>): Promise<void> {\n        const provider = this.throwIfFileSystemIsReadonly(await this.withProvider(resource), resource);\n\n        // Validate trash support\n        const useTrash = !!options?.useTrash;\n        if (useTrash && !(provider.capabilities & FileSystemProviderCapabilities.Trash)) {\n            throw new Error(nls.localizeByDefault(\"Unable to delete file '{0}' via trash because provider does not support it.\", this.resourceForError(resource)));\n        }\n\n        // Validate delete\n        const exists = await this.exists(resource);\n        if (!exists) {\n            throw new FileOperationError(nls.localizeByDefault(\"Unable to delete nonexistent file '{0}'\", this.resourceForError(resource)), FileOperationResult.FILE_NOT_FOUND);\n        }\n\n        // Validate recursive\n        const recursive = !!options?.recursive;\n        if (!recursive && exists) {\n            const stat = await this.resolve(resource);\n            if (stat.isDirectory && Array.isArray(stat.children) && stat.children.length > 0) {\n                throw new Error(nls.localizeByDefault(\"Unable to delete non-empty folder '{0}'.\", this.resourceForError(resource)));\n            }\n        }\n\n        // Delete through provider\n        await provider.delete(resource, { recursive, useTrash });\n\n        // Events\n        this.onDidRunOperationEmitter.fire(new FileOperationEvent(resource, FileOperation.DELETE));\n    }\n\n    // #endregion\n\n    // #region File Watching\n\n    private onDidFilesChangeEmitter = new Emitter<FileChangesEvent>();\n    /**\n     * An event that is emitted when files are changed on the disk.\n     */\n    get onDidFilesChange(): Event<FileChangesEvent> {\n        return this.onDidFilesChangeEmitter.event;\n    }\n\n    private activeWatchers = new Map<string, { disposable: Disposable, count: number }>();\n\n    watch(resource: URI, options: WatchOptions = { recursive: false, excludes: [] }): Disposable {\n        const resolvedOptions: WatchOptions = {\n            ...options,\n            // always ignore temporary upload files\n            excludes: options.excludes.concat('**/theia_upload_*')\n        };\n\n        let watchDisposed = false;\n        let watchDisposable = Disposable.create(() => watchDisposed = true);\n\n        // Watch and wire in disposable which is async but\n        // check if we got disposed meanwhile and forward\n        this.doWatch(resource, resolvedOptions).then(disposable => {\n            if (watchDisposed) {\n                disposable.dispose();\n            } else {\n                watchDisposable = disposable;\n            }\n        }, error => console.error(error));\n\n        return Disposable.create(() => watchDisposable.dispose());\n    }\n\n    async doWatch(resource: URI, options: WatchOptions): Promise<Disposable> {\n        const provider = await this.withProvider(resource);\n        const key = this.toWatchKey(provider, resource, options);\n\n        // Only start watching if we are the first for the given key\n        const watcher = this.activeWatchers.get(key) || { count: 0, disposable: provider.watch(resource, options) };\n        if (!this.activeWatchers.has(key)) {\n            this.activeWatchers.set(key, watcher);\n        }\n\n        // Increment usage counter\n        watcher.count += 1;\n\n        return Disposable.create(() => {\n\n            // Unref\n            watcher.count--;\n\n            // Dispose only when last user is reached\n            if (watcher.count === 0) {\n                watcher.disposable.dispose();\n                this.activeWatchers.delete(key);\n            }\n        });\n    }\n\n    private toWatchKey(provider: FileSystemProvider, resource: URI, options: WatchOptions): string {\n        return [\n            this.toMapKey(provider, resource),  // lowercase path if the provider is case insensitive\n            String(options.recursive),          // use recursive: true | false as part of the key\n            options.excludes.join()             // use excludes as part of the key\n        ].join();\n    }\n\n    // #endregion\n\n    // #region Helpers\n\n    private writeQueues: Map<string, Promise<void>> = new Map();\n\n    private ensureWriteQueue(provider: FileSystemProvider, resource: URI, task: () => Promise<void>): Promise<void> {\n        // ensure to never write to the same resource without finishing\n        // the one write. this ensures a write finishes consistently\n        // (even with error) before another write is done.\n        const queueKey = this.toMapKey(provider, resource);\n        const writeQueue = (this.writeQueues.get(queueKey) || Promise.resolve()).then(task, task);\n        this.writeQueues.set(queueKey, writeQueue);\n        return writeQueue;\n    }\n\n    private toMapKey(provider: FileSystemProvider, resource: URI): string {\n        const isPathCaseSensitive = !!(provider.capabilities & FileSystemProviderCapabilities.PathCaseSensitive);\n\n        return isPathCaseSensitive ? resource.toString() : resource.toString().toLowerCase();\n    }\n\n    private async doWriteBuffered(provider: FileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, readableOrStreamOrBufferedStream: BinaryBufferReadable | BinaryBufferReadableStream | BinaryBufferReadableBufferedStream): Promise<void> {\n        return this.ensureWriteQueue(provider, resource, async () => {\n\n            // open handle\n            const handle = await provider.open(resource, { create: true });\n\n            // write into handle until all bytes from buffer have been written\n            try {\n                if (isReadableStream(readableOrStreamOrBufferedStream) || isReadableBufferedStream(readableOrStreamOrBufferedStream)) {\n                    await this.doWriteStreamBufferedQueued(provider, handle, readableOrStreamOrBufferedStream);\n                } else {\n                    await this.doWriteReadableBufferedQueued(provider, handle, readableOrStreamOrBufferedStream);\n                }\n            } catch (error) {\n                throw ensureFileSystemProviderError(error);\n            } finally {\n\n                // close handle always\n                await provider.close(handle);\n            }\n        });\n    }\n\n    private async doWriteStreamBufferedQueued(provider: FileSystemProviderWithOpenReadWriteCloseCapability, handle: number, streamOrBufferedStream: BinaryBufferReadableStream | BinaryBufferReadableBufferedStream): Promise<void> {\n        let posInFile = 0;\n        let stream: BinaryBufferReadableStream;\n\n        // Buffered stream: consume the buffer first by writing\n        // it to the target before reading from the stream.\n        if (isReadableBufferedStream(streamOrBufferedStream)) {\n            if (streamOrBufferedStream.buffer.length > 0) {\n                const chunk = BinaryBuffer.concat(streamOrBufferedStream.buffer);\n                await this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\n\n                posInFile += chunk.byteLength;\n            }\n\n            // If the stream has been consumed, return early\n            if (streamOrBufferedStream.ended) {\n                return;\n            }\n\n            stream = streamOrBufferedStream.stream;\n        }\n\n        // Unbuffered stream - just take as is\n        else {\n            stream = streamOrBufferedStream;\n        }\n\n        return new Promise(async (resolve, reject) => {\n\n            stream.on('data', async chunk => {\n\n                // pause stream to perform async write operation\n                stream.pause();\n\n                try {\n                    await this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\n                } catch (error) {\n                    return reject(error);\n                }\n\n                posInFile += chunk.byteLength;\n\n                // resume stream now that we have successfully written\n                // run this on the next tick to prevent increasing the\n                // execution stack because resume() may call the event\n                // handler again before finishing.\n                setTimeout(() => stream.resume());\n            });\n\n            stream.on('error', error => reject(error));\n            stream.on('end', () => resolve());\n        });\n    }\n\n    private async doWriteReadableBufferedQueued(provider: FileSystemProviderWithOpenReadWriteCloseCapability, handle: number, readable: BinaryBufferReadable): Promise<void> {\n        let posInFile = 0;\n\n        let chunk: BinaryBuffer | null;\n        while ((chunk = readable.read()) !== null) {\n            await this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\n\n            posInFile += chunk.byteLength;\n        }\n    }\n\n    private async doWriteBuffer(provider: FileSystemProviderWithOpenReadWriteCloseCapability, handle: number, buffer: BinaryBuffer, length: number, posInFile: number, posInBuffer: number): Promise<void> {\n        let totalBytesWritten = 0;\n        while (totalBytesWritten < length) {\n            const bytesWritten = await provider.write(handle, posInFile + totalBytesWritten, buffer.buffer, posInBuffer + totalBytesWritten, length - totalBytesWritten);\n            totalBytesWritten += bytesWritten;\n        }\n    }\n\n    private async doWriteUnbuffered(provider: FileSystemProviderWithFileReadWriteCapability, resource: URI, bufferOrReadableOrStreamOrBufferedStream: BinaryBuffer | BinaryBufferReadable | BinaryBufferReadableStream | BinaryBufferReadableBufferedStream): Promise<void> {\n        return this.ensureWriteQueue(provider, resource, () => this.doWriteUnbufferedQueued(provider, resource, bufferOrReadableOrStreamOrBufferedStream));\n    }\n\n    private async doWriteUnbufferedQueued(provider: FileSystemProviderWithFileReadWriteCapability, resource: URI, bufferOrReadableOrStreamOrBufferedStream: BinaryBuffer | BinaryBufferReadable | BinaryBufferReadableStream | BinaryBufferReadableBufferedStream): Promise<void> {\n        let buffer: BinaryBuffer;\n        if (bufferOrReadableOrStreamOrBufferedStream instanceof BinaryBuffer) {\n            buffer = bufferOrReadableOrStreamOrBufferedStream;\n        } else if (isReadableStream(bufferOrReadableOrStreamOrBufferedStream)) {\n            buffer = await BinaryBufferReadableStream.toBuffer(bufferOrReadableOrStreamOrBufferedStream);\n        } else if (isReadableBufferedStream(bufferOrReadableOrStreamOrBufferedStream)) {\n            buffer = await BinaryBufferReadableBufferedStream.toBuffer(bufferOrReadableOrStreamOrBufferedStream);\n        } else {\n            buffer = BinaryBufferReadable.toBuffer(bufferOrReadableOrStreamOrBufferedStream);\n        }\n\n        return provider.writeFile(resource, buffer.buffer, { create: true, overwrite: true });\n    }\n\n    private async doPipeBuffered(sourceProvider: FileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: FileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n        return this.ensureWriteQueue(targetProvider, target, () => this.doPipeBufferedQueued(sourceProvider, source, targetProvider, target));\n    }\n\n    private async doPipeBufferedQueued(sourceProvider: FileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: FileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n        let sourceHandle: number | undefined = undefined;\n        let targetHandle: number | undefined = undefined;\n\n        try {\n\n            // Open handles\n            sourceHandle = await sourceProvider.open(source, { create: false });\n            targetHandle = await targetProvider.open(target, { create: true });\n\n            const buffer = BinaryBuffer.alloc(this.BUFFER_SIZE);\n\n            let posInFile = 0;\n            let posInBuffer = 0;\n            let bytesRead = 0;\n            do {\n                // read from source (sourceHandle) at current position (posInFile) into buffer (buffer) at\n                // buffer position (posInBuffer) up to the size of the buffer (buffer.byteLength).\n                bytesRead = await sourceProvider.read(sourceHandle, posInFile, buffer.buffer, posInBuffer, buffer.byteLength - posInBuffer);\n\n                // write into target (targetHandle) at current position (posInFile) from buffer (buffer) at\n                // buffer position (posInBuffer) all bytes we read (bytesRead).\n                await this.doWriteBuffer(targetProvider, targetHandle, buffer, bytesRead, posInFile, posInBuffer);\n\n                posInFile += bytesRead;\n                posInBuffer += bytesRead;\n\n                // when buffer full, fill it again from the beginning\n                if (posInBuffer === buffer.byteLength) {\n                    posInBuffer = 0;\n                }\n            } while (bytesRead > 0);\n        } catch (error) {\n            throw ensureFileSystemProviderError(error);\n        } finally {\n            await Promise.all([\n                typeof sourceHandle === 'number' ? sourceProvider.close(sourceHandle) : Promise.resolve(),\n                typeof targetHandle === 'number' ? targetProvider.close(targetHandle) : Promise.resolve(),\n            ]);\n        }\n    }\n\n    private async doPipeUnbuffered(sourceProvider: FileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: FileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\n        return this.ensureWriteQueue(targetProvider, target, () => this.doPipeUnbufferedQueued(sourceProvider, source, targetProvider, target));\n    }\n\n    private async doPipeUnbufferedQueued(sourceProvider: FileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: FileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\n        return targetProvider.writeFile(target, await sourceProvider.readFile(source), { create: true, overwrite: true });\n    }\n\n    private async doPipeUnbufferedToBuffered(sourceProvider: FileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: FileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n        return this.ensureWriteQueue(targetProvider, target, () => this.doPipeUnbufferedToBufferedQueued(sourceProvider, source, targetProvider, target));\n    }\n\n    private async doPipeUnbufferedToBufferedQueued(sourceProvider: FileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: FileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n\n        // Open handle\n        const targetHandle = await targetProvider.open(target, { create: true });\n\n        // Read entire buffer from source and write buffered\n        try {\n            const buffer = await sourceProvider.readFile(source);\n            await this.doWriteBuffer(targetProvider, targetHandle, BinaryBuffer.wrap(buffer), buffer.byteLength, 0, 0);\n        } catch (error) {\n            throw ensureFileSystemProviderError(error);\n        } finally {\n            await targetProvider.close(targetHandle);\n        }\n    }\n\n    private async doPipeBufferedToUnbuffered(sourceProvider: FileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: FileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\n\n        // Read buffer via stream buffered\n        const buffer = await BinaryBufferReadableStream.toBuffer(this.readFileBuffered(sourceProvider, source, CancellationToken.None));\n\n        // Write buffer into target at once\n        await this.doWriteUnbuffered(targetProvider, target, buffer);\n    }\n\n    protected throwIfFileSystemIsReadonly<T extends FileSystemProvider>(provider: T, resource: URI): T {\n        if (provider.capabilities & FileSystemProviderCapabilities.Readonly) {\n            throw new FileOperationError(nls.localizeByDefault(\"Unable to modify read-only file '{0}'\", this.resourceForError(resource)), FileOperationResult.FILE_PERMISSION_DENIED);\n        }\n\n        return provider;\n    }\n\n    private resourceForError(resource: URI): string {\n        return this.labelProvider.getLongName(resource);\n    }\n\n    // #endregion\n\n    // #region File operation participants\n\n    private readonly participants: FileOperationParticipant[] = [];\n\n    addFileOperationParticipant(participant: FileOperationParticipant): Disposable {\n        this.participants.push(participant);\n\n        return Disposable.create(() => {\n            const index = this.participants.indexOf(participant);\n            if (index > -1) {\n                this.participants.splice(index, 1);\n            }\n        });\n    }\n\n    async runFileOperationParticipants(target: URI, source: URI | undefined, operation: FileOperation): Promise<void> {\n        const participantsTimeout = this.preferences['files.participants.timeout'];\n        if (participantsTimeout <= 0 || this.participants.length === 0) {\n            return;\n        }\n\n        const cancellationTokenSource = new CancellationTokenSource();\n\n        return this.progressService.withProgress(\n            this.progressLabel(operation),\n            'notification',\n            async () => {\n                for (const participant of this.participants) {\n                    if (cancellationTokenSource.token.isCancellationRequested) {\n                        break;\n                    }\n\n                    try {\n                        const promise = participant.participate(target, source, operation, participantsTimeout, cancellationTokenSource.token);\n                        await Promise.race([\n                            promise,\n                            timeout(participantsTimeout, cancellationTokenSource.token).then(() => cancellationTokenSource.dispose(), () => { /* no-op if cancelled */ })\n                        ]);\n                    } catch (err) {\n                        console.warn(err);\n                    }\n                }\n            },\n            () => {\n                cancellationTokenSource.cancel();\n            });\n    }\n\n    private progressLabel(operation: FileOperation): string {\n        switch (operation) {\n            case FileOperation.CREATE:\n                return nls.localizeByDefault(\"Running 'File Create' participants...\");\n            case FileOperation.MOVE:\n                return nls.localizeByDefault(\"Running 'File Rename' participants...\");\n            case FileOperation.COPY:\n                return nls.localizeByDefault(\"Running 'File Copy' participants...\");\n            case FileOperation.DELETE:\n                return nls.localizeByDefault(\"Running 'File Delete' participants...\");\n        }\n    }\n\n    // #endregion\n\n    // #region encoding\n\n    protected async getWriteEncoding(resource: URI, options?: WriteEncodingOptions): Promise<ResourceEncoding> {\n        const encoding = await this.getEncodingForResource(resource, options ? options.encoding : undefined);\n        return this.encodingService.toResourceEncoding(encoding, {\n            overwriteEncoding: options?.overwriteEncoding,\n            read: async length => {\n                const buffer = await BinaryBufferReadableStream.toBuffer((await this.readFileStream(resource, { length })).value);\n                return buffer.buffer;\n            }\n        });\n    }\n\n    protected getReadEncoding(resource: URI, options?: ReadEncodingOptions, detectedEncoding?: string): Promise<string> {\n        let preferredEncoding: string | undefined;\n\n        // Encoding passed in as option\n        if (options?.encoding) {\n            if (detectedEncoding === UTF8_with_bom && options.encoding === UTF8) {\n                preferredEncoding = UTF8_with_bom; // indicate the file has BOM if we are to resolve with UTF 8\n            } else {\n                preferredEncoding = options.encoding; // give passed in encoding highest priority\n            }\n        } else if (detectedEncoding) {\n            preferredEncoding = detectedEncoding;\n        }\n\n        return this.getEncodingForResource(resource, preferredEncoding);\n    }\n\n    protected async getEncodingForResource(resource: URI, preferredEncoding?: string): Promise<string> {\n        resource = await this.toUnderlyingResource(resource);\n        return this.encodingRegistry.getEncodingForResource(resource, preferredEncoding);\n    }\n\n    /**\n     * Converts to an underlying fs provider resource format.\n     *\n     * For example converting `user-storage` resources to `file` resources under a user home:\n     * user-storage:/user/settings.json => file://home/.theia/settings.json\n     */\n    async toUnderlyingResource(resource: URI): Promise<URI> {\n        let provider = await this.withProvider(resource);\n        while (provider instanceof DelegatingFileSystemProvider) {\n            resource = provider.toUnderlyingResource(resource);\n            provider = await this.withProvider(resource);\n        }\n        return resource;\n    }\n\n    // #endregion\n\n    protected handleFileWatchError(): void {\n        this.watcherErrorHandler.handleError();\n    }\n}\n","// *****************************************************************************\n// Copyright (C) 2017 TypeFox and others.\n//\n// This program and the accompanying materials are made available under the\n// terms of the Eclipse Public License v. 2.0 which is available at\n// http://www.eclipse.org/legal/epl-2.0.\n//\n// This Source Code may also be made available under the following Secondary\n// Licenses when the conditions for such availability set forth in the Eclipse\n// Public License v. 2.0 are satisfied: GNU General Public License, version 2\n// with the GNU Classpath Exception which is available at\n// https://www.gnu.org/software/classpath/license.html.\n//\n// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0\n// *****************************************************************************\n\nimport { interfaces } from '@theia/core/shared/inversify';\nimport {\n    createPreferenceProxy,\n    PreferenceProxy,\n    PreferenceService,\n    PreferenceSchema,\n    PreferenceContribution\n} from '@theia/core/lib/browser/preferences';\nimport { SUPPORTED_ENCODINGS } from '@theia/core/lib/browser/supported-encodings';\nimport { nls } from '@theia/core/lib/common/nls';\n\n// See https://github.com/Microsoft/vscode/issues/30180\nexport const WIN32_MAX_FILE_SIZE_MB = 300; // 300 MB\nexport const GENERAL_MAX_FILE_SIZE_MB = 16 * 1024; // 16 GB\n\nexport const MAX_FILE_SIZE_MB = typeof process === 'object'\n    ? process.arch === 'ia32'\n        ? WIN32_MAX_FILE_SIZE_MB\n        : GENERAL_MAX_FILE_SIZE_MB\n    : 32;\n\nexport const filesystemPreferenceSchema: PreferenceSchema = {\n    type: 'object',\n    properties: {\n        'files.watcherExclude': {\n            // eslint-disable-next-line max-len\n            description: nls.localizeByDefault('Configure paths or [glob patterns](https://aka.ms/vscode-glob-patterns) to exclude from file watching. Paths can either be relative to the watched folder or absolute. Glob patterns are matched relative from the watched folder. When you experience the file watcher process consuming a lot of CPU, make sure to exclude large folders that are of less interest (such as build output folders).'),\n            additionalProperties: {\n                type: 'boolean'\n            },\n            default: {\n                '**/.git/objects/**': true,\n                '**/.git/subtree-cache/**': true,\n                '**/node_modules/**': true\n            },\n            scope: 'resource'\n        },\n        'files.exclude': {\n            type: 'object',\n            default: { '**/.git': true, '**/.svn': true, '**/.hg': true, '**/CVS': true, '**/.DS_Store': true },\n            // eslint-disable-next-line max-len\n            markdownDescription: nls.localize('theia/filesystem/filesExclude', 'Configure glob patterns for excluding files and folders. For example, the file Explorer decides which files and folders to show or hide based on this setting.'),\n            scope: 'resource'\n        },\n        'files.enableTrash': {\n            type: 'boolean',\n            default: true,\n            description: nls.localizeByDefault('Moves files/folders to the OS trash (recycle bin on Windows) when deleting. Disabling this will delete files/folders permanently.')\n        },\n        'files.associations': {\n            type: 'object',\n            markdownDescription: nls.localizeByDefault(\n                // eslint-disable-next-line max-len\n                'Configure [glob patterns](https://aka.ms/vscode-glob-patterns) of file associations to languages (for example `\\\"*.extension\\\": \\\"html\\\"`). Patterns will match on the absolute path of a file if they contain a path separator and will match on the name of the file otherwise. These have precedence over the default associations of the languages installed.'\n            )\n        },\n        'files.autoGuessEncoding': {\n            type: 'boolean',\n            default: false,\n            // eslint-disable-next-line max-len\n            description: nls.localizeByDefault('When enabled, the editor will attempt to guess the character set encoding when opening files. This setting can also be configured per language. Note, this setting is not respected by text search. Only {0} is respected.', '`#files.encoding#`'),\n            scope: 'language-overridable',\n            included: Object.keys(SUPPORTED_ENCODINGS).length > 1\n        },\n        'files.participants.timeout': {\n            type: 'number',\n            default: 5000,\n            markdownDescription: nls.localizeByDefault(\n                'Timeout in milliseconds after which file participants for create, rename, and delete are cancelled. Use `0` to disable participants.'\n            )\n        },\n        'files.maxFileSizeMB': {\n            type: 'number',\n            default: MAX_FILE_SIZE_MB,\n            markdownDescription: nls.localize('theia/filesystem/maxFileSizeMB', 'Controls the max file size in MB which is possible to open.')\n        },\n        'files.trimTrailingWhitespace': {\n            type: 'boolean',\n            default: false,\n            description: nls.localizeByDefault('When enabled, will trim trailing whitespace when saving a file.'),\n            scope: 'language-overridable'\n        },\n        'files.maxConcurrentUploads': {\n            type: 'integer',\n            default: 1,\n            description: nls.localize(\n                'theia/filesystem/maxConcurrentUploads',\n                'Maximum number of concurrent files to upload when uploading multiple files. 0 means all files will be uploaded concurrently.'\n            ),\n        }\n    }\n};\n\nexport interface FileSystemConfiguration {\n    'files.watcherExclude': { [globPattern: string]: boolean }\n    'files.exclude': { [key: string]: boolean }\n    'files.enableTrash': boolean\n    'files.associations': { [filepattern: string]: string }\n    'files.encoding': string\n    'files.autoGuessEncoding': boolean\n    'files.participants.timeout': number\n    'files.maxFileSizeMB': number\n    'files.trimTrailingWhitespace': boolean\n    'files.maxConcurrentUploads': number\n}\n\nexport const FileSystemPreferenceContribution = Symbol('FilesystemPreferenceContribution');\nexport const FileSystemPreferences = Symbol('FileSystemPreferences');\nexport type FileSystemPreferences = PreferenceProxy<FileSystemConfiguration>;\n\nexport function createFileSystemPreferences(preferences: PreferenceService, schema: PreferenceSchema = filesystemPreferenceSchema): FileSystemPreferences {\n    return createPreferenceProxy(preferences, schema);\n}\n\nexport function bindFileSystemPreferences(bind: interfaces.Bind): void {\n    bind(FileSystemPreferences).toDynamicValue(ctx => {\n        const preferences = ctx.container.get<PreferenceService>(PreferenceService);\n        const contribution = ctx.container.get<PreferenceContribution>(FileSystemPreferenceContribution);\n        return createFileSystemPreferences(preferences, contribution.schema);\n    }).inSingletonScope();\n    bind(FileSystemPreferenceContribution).toConstantValue({ schema: filesystemPreferenceSchema });\n    bind(PreferenceContribution).toService(FileSystemPreferenceContribution);\n}\n","// *****************************************************************************\n// Copyright (C) 2020 Arm and others.\n//\n// This program and the accompanying materials are made available under the\n// terms of the Eclipse Public License v. 2.0 which is available at\n// http://www.eclipse.org/legal/epl-2.0.\n//\n// This Source Code may also be made available under the following Secondary\n// Licenses when the conditions for such availability set forth in the Eclipse\n// Public License v. 2.0 are satisfied: GNU General Public License, version 2\n// with the GNU Classpath Exception which is available at\n// https://www.gnu.org/software/classpath/license.html.\n//\n// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0\n// *****************************************************************************\n\nimport { injectable, inject } from '@theia/core/shared/inversify';\nimport { environment } from '@theia/core/shared/@theia/application-package/lib/environment';\nimport { MessageService } from '@theia/core';\nimport { WindowService } from '@theia/core/lib/browser/window/window-service';\n\n@injectable()\nexport class FileSystemWatcherErrorHandler {\n\n    @inject(MessageService) protected readonly messageService: MessageService;\n    @inject(WindowService) protected readonly windowService: WindowService;\n\n    protected watchHandlesExhausted: boolean = false;\n\n    protected get instructionsLink(): string {\n        return 'https://code.visualstudio.com/docs/setup/linux#_visual-studio-code-is-unable-to-watch-for-file-changes-in-this-large-workspace-error-enospc';\n    }\n\n    public async handleError(): Promise<void> {\n        if (!this.watchHandlesExhausted) {\n            this.watchHandlesExhausted = true;\n            if (this.isElectron()) {\n                const instructionsAction = 'Instructions';\n                const action = await this.messageService.warn(\n                    'Unable to watch for file changes in this large workspace.  Please follow the instructions link to resolve this issue.',\n                    { timeout: 60000 },\n                    instructionsAction\n                );\n                if (action === instructionsAction) {\n                    this.windowService.openNewWindow(this.instructionsLink, { external: true });\n                }\n            } else {\n                await this.messageService.warn(\n                    'Unable to watch for file changes in this large workspace.  The information you see may not include recent file changes.',\n                    { timeout: 60000 }\n                );\n            }\n        }\n    }\n\n    protected isElectron(): boolean {\n        return environment.electron.is();\n    }\n\n}\n","// *****************************************************************************\n// Copyright (C) 2020 TypeFox and others.\n//\n// This program and the accompanying materials are made available under the\n// terms of the Eclipse Public License v. 2.0 which is available at\n// http://www.eclipse.org/legal/epl-2.0.\n//\n// This Source Code may also be made available under the following Secondary\n// Licenses when the conditions for such availability set forth in the Eclipse\n// Public License v. 2.0 are satisfied: GNU General Public License, version 2\n// with the GNU Classpath Exception which is available at\n// https://www.gnu.org/software/classpath/license.html.\n//\n// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0\n// *****************************************************************************\n\nimport URI from '@theia/core/lib/common/uri';\nimport { Event, Emitter, CancellationToken } from '@theia/core/lib/common';\nimport { Disposable, DisposableCollection } from '@theia/core/lib/common/disposable';\nimport {\n    FileSystemProvider, FileSystemProviderCapabilities, WatchOptions, FileDeleteOptions, FileOverwriteOptions, FileWriteOptions, FileOpenOptions, FileChange, Stat, FileType,\n    hasReadWriteCapability, hasFileFolderCopyCapability, hasOpenReadWriteCloseCapability, hasAccessCapability, FileUpdateOptions, hasUpdateCapability, FileUpdateResult,\n    FileReadStreamOptions,\n    hasFileReadStreamCapability\n} from './files';\nimport type { TextDocumentContentChangeEvent } from '@theia/core/shared/vscode-languageserver-protocol';\nimport { ReadableStreamEvents } from '@theia/core/lib/common/stream';\n\nexport class DelegatingFileSystemProvider implements Required<FileSystemProvider>, Disposable {\n\n    private readonly onDidChangeFileEmitter = new Emitter<readonly FileChange[]>();\n    readonly onDidChangeFile = this.onDidChangeFileEmitter.event;\n\n    private readonly onFileWatchErrorEmitter = new Emitter<void>();\n    readonly onFileWatchError = this.onFileWatchErrorEmitter.event;\n\n    constructor(\n        protected readonly delegate: FileSystemProvider,\n        protected readonly options: DelegatingFileSystemProvider.Options,\n        protected readonly toDispose = new DisposableCollection()\n    ) {\n        this.toDispose.push(this.onDidChangeFileEmitter);\n        this.toDispose.push(delegate.onDidChangeFile(changes => this.handleFileChanges(changes)));\n        this.toDispose.push(this.onFileWatchErrorEmitter);\n        this.toDispose.push(delegate.onFileWatchError(changes => this.onFileWatchErrorEmitter.fire()));\n    }\n\n    dispose(): void {\n        this.toDispose.dispose();\n    }\n\n    get capabilities(): FileSystemProviderCapabilities {\n        return this.delegate.capabilities;\n    }\n\n    get onDidChangeCapabilities(): Event<void> {\n        return this.delegate.onDidChangeCapabilities;\n    }\n\n    watch(resource: URI, opts: WatchOptions): Disposable {\n        return this.delegate.watch(this.toUnderlyingResource(resource), opts);\n    }\n\n    stat(resource: URI): Promise<Stat> {\n        return this.delegate.stat(this.toUnderlyingResource(resource));\n    }\n\n    access(resource: URI, mode?: number): Promise<void> {\n        if (hasAccessCapability(this.delegate)) {\n            return this.delegate.access(this.toUnderlyingResource(resource), mode);\n        }\n        throw new Error('not supported');\n    }\n\n    fsPath(resource: URI): Promise<string> {\n        if (hasAccessCapability(this.delegate)) {\n            return this.delegate.fsPath(this.toUnderlyingResource(resource));\n        }\n        throw new Error('not supported');\n    }\n\n    mkdir(resource: URI): Promise<void> {\n        return this.delegate.mkdir(this.toUnderlyingResource(resource));\n    }\n\n    rename(from: URI, to: URI, opts: FileOverwriteOptions): Promise<void> {\n        return this.delegate.rename(this.toUnderlyingResource(from), this.toUnderlyingResource(to), opts);\n    }\n\n    copy(from: URI, to: URI, opts: FileOverwriteOptions): Promise<void> {\n        if (hasFileFolderCopyCapability(this.delegate)) {\n            return this.delegate.copy(this.toUnderlyingResource(from), this.toUnderlyingResource(to), opts);\n        }\n        throw new Error('not supported');\n    }\n\n    readFile(resource: URI): Promise<Uint8Array> {\n        if (hasReadWriteCapability(this.delegate)) {\n            return this.delegate.readFile(this.toUnderlyingResource(resource));\n        }\n        throw new Error('not supported');\n    }\n\n    readFileStream(resource: URI, opts: FileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array> {\n        if (hasFileReadStreamCapability(this.delegate)) {\n            return this.delegate.readFileStream(this.toUnderlyingResource(resource), opts, token);\n        }\n        throw new Error('not supported');\n    }\n\n    readdir(resource: URI): Promise<[string, FileType][]> {\n        return this.delegate.readdir(this.toUnderlyingResource(resource));\n    }\n\n    writeFile(resource: URI, content: Uint8Array, opts: FileWriteOptions): Promise<void> {\n        if (hasReadWriteCapability(this.delegate)) {\n            return this.delegate.writeFile(this.toUnderlyingResource(resource), content, opts);\n        }\n        throw new Error('not supported');\n    }\n\n    open(resource: URI, opts: FileOpenOptions): Promise<number> {\n        if (hasOpenReadWriteCloseCapability(this.delegate)) {\n            return this.delegate.open(this.toUnderlyingResource(resource), opts);\n        }\n        throw new Error('not supported');\n    }\n\n    close(fd: number): Promise<void> {\n        if (hasOpenReadWriteCloseCapability(this.delegate)) {\n            return this.delegate.close(fd);\n        }\n        throw new Error('not supported');\n    }\n\n    read(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n        if (hasOpenReadWriteCloseCapability(this.delegate)) {\n            return this.delegate.read(fd, pos, data, offset, length);\n        }\n        throw new Error('not supported');\n    }\n\n    write(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n        if (hasOpenReadWriteCloseCapability(this.delegate)) {\n            return this.delegate.write(fd, pos, data, offset, length);\n        }\n        throw new Error('not supported');\n    }\n\n    delete(resource: URI, opts: FileDeleteOptions): Promise<void> {\n        return this.delegate.delete(this.toUnderlyingResource(resource), opts);\n    }\n\n    updateFile(resource: URI, changes: TextDocumentContentChangeEvent[], opts: FileUpdateOptions): Promise<FileUpdateResult> {\n        if (hasUpdateCapability(this.delegate)) {\n            return this.delegate.updateFile(resource, changes, opts);\n        }\n        throw new Error('not supported');\n    }\n\n    protected handleFileChanges(changes: readonly FileChange[]): void {\n        const delegatingChanges: FileChange[] = [];\n        for (const change of changes) {\n            const delegatingResource = this.fromUnderlyingResource(change.resource);\n            if (delegatingResource) {\n                delegatingChanges.push({\n                    resource: delegatingResource,\n                    type: change.type\n                });\n            }\n        }\n        if (delegatingChanges.length) {\n            this.onDidChangeFileEmitter.fire(delegatingChanges);\n        }\n    }\n\n    /**\n     * Converts to an underlying fs provider resource format.\n     *\n     * For example converting `user-storage` resources to `file` resources under a user home:\n     * user-storage:/user/settings.json => file://home/.theia/settings.json\n     */\n    toUnderlyingResource(resource: URI): URI {\n        const underlying = this.options.uriConverter.to(resource);\n        if (!underlying) {\n            throw new Error('invalid resource: ' + resource.toString());\n        }\n        return underlying;\n    }\n\n    /**\n     * Converts from an underlying fs provider resource format.\n     *\n     * For example converting `file` resources under a user home to `user-storage` resource:\n     * - file://home/.theia/settings.json => user-storage:/user/settings.json\n     * - file://documents/some-document.txt => undefined\n     */\n    fromUnderlyingResource(resource: URI): URI | undefined {\n        return this.options.uriConverter.from(resource);\n    }\n\n}\nexport namespace DelegatingFileSystemProvider {\n    export interface Options {\n        uriConverter: URIConverter\n    }\n    export interface URIConverter {\n        /**\n         * Converts to an underlying fs provider resource format.\n         * Returns undefined if the given resource is not valid resource.\n         *\n         * For example converting `user-storage` resources to `file` resources under a user home:\n         * user-storage:/user/settings.json => file://home/.theia/settings.json\n         * user-storage:/settings.json => undefined\n         */\n        to(resource: URI): URI | undefined;\n        /**\n         * Converts from an underlying fs provider resource format.\n         *\n         * For example converting `file` resources under a user home to `user-storage` resource:\n         * - file://home/.theia/settings.json => user-storage:/settings.json\n         * - file://documents/some-document.txt => undefined\n         */\n        from(resource: URI): URI | undefined;\n    }\n}\n","// *****************************************************************************\n// Copyright (C) 2018 Ericsson and others.\n//\n// This program and the accompanying materials are made available under the\n// terms of the Eclipse Public License v. 2.0 which is available at\n// http://www.eclipse.org/legal/epl-2.0.\n//\n// This Source Code may also be made available under the following Secondary\n// Licenses when the conditions for such availability set forth in the Eclipse\n// Public License v. 2.0 are satisfied: GNU General Public License, version 2\n// with the GNU Classpath Exception which is available at\n// https://www.gnu.org/software/classpath/license.html.\n//\n// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0\n// *****************************************************************************\n\nimport { FileStat } from '../common/files';\nimport URI from '@theia/core/lib/common/uri';\n\nexport namespace FileSystemUtils {\n    export const FILE_NAME_SEPARATOR = ' ';\n\n    /**\n     * Generate unique URI for a given parent which does not collide\n     *\n     * @param parent the `FileStat` of the parent\n     * @param targetUri the initial URI\n     * @param isDirectory indicates whether the given targetUri represents a directory\n     * @param suffix an optional string to append to the file name, in case of collision (e.g. `copy`)\n     */\n    export function generateUniqueResourceURI(parent: FileStat, targetUri: URI, isDirectory: boolean, suffix?: string): URI {\n        const children = !parent.children ? [] : parent.children!.map(child => child.resource);\n        let name = targetUri.path.name;\n        let extension = targetUri.path.ext;\n        if (!name) {\n            // special case for dotfiles (e.g. '.foobar'): use the extension as the name\n            name = targetUri.path.ext;\n            extension = '';\n        }\n        // we want the path base for directories with the source path `foo.bar` to be generated as `foo.bar copy` and not `foo copy.bar` as we do for files\n        if (isDirectory) {\n            name = name + extension;\n            extension = '';\n        }\n\n        let base = name + extension;\n        // test if the name already contains the suffix or the suffix + index, so we don't add it again\n        const nameRegex = RegExp(`.*${FileSystemUtils.FILE_NAME_SEPARATOR}${suffix}(${FileSystemUtils.FILE_NAME_SEPARATOR}[0-9]*)?$`);\n        if (suffix && !nameRegex.test(name) && children.some(child => child.path.base === base)) {\n            name = name + FILE_NAME_SEPARATOR + suffix;\n            base = name + extension;\n        }\n        if (suffix && nameRegex.test(name)) {\n            // remove the existing index from the name, so we can generate a new one\n            name = name.replace(RegExp(`${FILE_NAME_SEPARATOR}[0-9]*$`), '');\n        }\n        let index = 0;\n        while (children.some(child => child.path.base === base)) {\n            index = index + 1;\n            base = name + FILE_NAME_SEPARATOR + index + extension;\n        }\n        return parent.resource.resolve(base);\n    }\n}\n","// *****************************************************************************\n// Copyright (C) 2020 TypeFox and others.\n//\n// This program and the accompanying materials are made available under the\n// terms of the Eclipse Public License v. 2.0 which is available at\n// http://www.eclipse.org/legal/epl-2.0.\n//\n// This Source Code may also be made available under the following Secondary\n// Licenses when the conditions for such availability set forth in the Eclipse\n// Public License v. 2.0 are satisfied: GNU General Public License, version 2\n// with the GNU Classpath Exception which is available at\n// https://www.gnu.org/software/classpath/license.html.\n//\n// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0\n// *****************************************************************************\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// based on https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/platform/files/common/io.ts\n\n/* eslint-disable max-len */\n\nimport URI from '@theia/core/lib/common/uri';\nimport { BinaryBuffer } from '@theia/core/lib/common//buffer';\nimport { CancellationToken, cancelled as canceled } from '@theia/core/lib/common/cancellation';\nimport { FileSystemProviderWithOpenReadWriteCloseCapability, FileReadStreamOptions, ensureFileSystemProviderError, createFileSystemProviderError, FileSystemProviderErrorCode } from './files';\nimport { WriteableStream, ErrorTransformer, DataTransformer } from '@theia/core/lib/common/stream';\n\nexport interface CreateReadStreamOptions extends FileReadStreamOptions {\n\n    /**\n     * The size of the buffer to use before sending to the stream.\n     */\n    bufferSize: number;\n\n    /**\n     * Allows to massage any possibly error that happens during reading.\n     */\n    errorTransformer?: ErrorTransformer;\n}\n\n/**\n * A helper to read a file from a provider with open/read/close capability into a stream.\n */\nexport async function readFileIntoStream<T>(\n    provider: FileSystemProviderWithOpenReadWriteCloseCapability,\n    resource: URI,\n    target: WriteableStream<T>,\n    transformer: DataTransformer<BinaryBuffer, T>,\n    options: CreateReadStreamOptions,\n    token: CancellationToken\n): Promise<void> {\n    let error: Error | undefined = undefined;\n\n    try {\n        await doReadFileIntoStream(provider, resource, target, transformer, options, token);\n    } catch (err) {\n        error = err;\n    } finally {\n        if (error && options.errorTransformer) {\n            error = options.errorTransformer(error);\n        }\n\n        target.end(error);\n    }\n}\n\nasync function doReadFileIntoStream<T>(provider: FileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, target: WriteableStream<T>, transformer: DataTransformer<BinaryBuffer, T>, options: CreateReadStreamOptions, token: CancellationToken): Promise<void> {\n\n    // Check for cancellation\n    throwIfCancelled(token);\n\n    // open handle through provider\n    const handle = await provider.open(resource, { create: false });\n\n    // Check for cancellation\n    throwIfCancelled(token);\n\n    try {\n        let totalBytesRead = 0;\n        let bytesRead = 0;\n        let allowedRemainingBytes = (options && typeof options.length === 'number') ? options.length : undefined;\n\n        let buffer = BinaryBuffer.alloc(Math.min(options.bufferSize, typeof allowedRemainingBytes === 'number' ? allowedRemainingBytes : options.bufferSize));\n\n        let posInFile = options && typeof options.position === 'number' ? options.position : 0;\n        let posInBuffer = 0;\n        do {\n            // read from source (handle) at current position (pos) into buffer (buffer) at\n            // buffer position (posInBuffer) up to the size of the buffer (buffer.byteLength).\n            bytesRead = await provider.read(handle, posInFile, buffer.buffer, posInBuffer, buffer.byteLength - posInBuffer);\n\n            posInFile += bytesRead;\n            posInBuffer += bytesRead;\n            totalBytesRead += bytesRead;\n\n            if (typeof allowedRemainingBytes === 'number') {\n                allowedRemainingBytes -= bytesRead;\n            }\n\n            // when buffer full, create a new one and emit it through stream\n            if (posInBuffer === buffer.byteLength) {\n                await target.write(transformer(buffer));\n\n                buffer = BinaryBuffer.alloc(Math.min(options.bufferSize, typeof allowedRemainingBytes === 'number' ? allowedRemainingBytes : options.bufferSize));\n\n                posInBuffer = 0;\n            }\n        } while (bytesRead > 0 && (typeof allowedRemainingBytes !== 'number' || allowedRemainingBytes > 0) && throwIfCancelled(token) && throwIfTooLarge(totalBytesRead, options));\n\n        // wrap up with last buffer (also respect maxBytes if provided)\n        if (posInBuffer > 0) {\n            let lastChunkLength = posInBuffer;\n            if (typeof allowedRemainingBytes === 'number') {\n                lastChunkLength = Math.min(posInBuffer, allowedRemainingBytes);\n            }\n\n            target.write(transformer(buffer.slice(0, lastChunkLength)));\n        }\n    } catch (error) {\n        throw ensureFileSystemProviderError(error);\n    } finally {\n        await provider.close(handle);\n    }\n}\n\nfunction throwIfCancelled(token: CancellationToken): boolean {\n    if (token.isCancellationRequested) {\n        throw canceled();\n    }\n\n    return true;\n}\n\nfunction throwIfTooLarge(totalBytesRead: number, options: CreateReadStreamOptions): boolean {\n\n    // Return early if file is too large to load and we have configured limits\n    if (options?.limits) {\n        if (typeof options.limits.memory === 'number' && totalBytesRead > options.limits.memory) {\n            throw createFileSystemProviderError('To open a file of this size, you need to restart and allow it to use more memory', FileSystemProviderErrorCode.FileExceedsMemoryLimit);\n        }\n\n        if (typeof options.limits.size === 'number' && totalBytesRead > options.limits.size) {\n            throw createFileSystemProviderError('File is too large to open', FileSystemProviderErrorCode.FileTooLarge);\n        }\n    }\n\n    return true;\n}\n"],"names":[],"sourceRoot":""}