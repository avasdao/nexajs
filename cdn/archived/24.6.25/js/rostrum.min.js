/* NEXA.js <Rostrum> v2024.06.25 */
/* Learn more at â†’ https://nexajs.org/pkg/rostrum */
var Rostrum=function(exports){function EventHandlers(){}function EventEmitter(){EventEmitter.init.call(this)}function $getMaxListeners(that){return void 0===that._maxListeners?EventEmitter.defaultMaxListeners:that._maxListeners}function _addListener(target,type,listener,prepend){var events,existing;if("function"!=typeof listener)throw new TypeError('"listener" argument must be a function');return(events=target._events)?(events.newListener&&(target.emit("newListener",type,listener.listener||listener),events=target._events),existing=events[type]):(events=target._events=new EventHandlers,target._eventsCount=0),existing?("function"==typeof existing?existing=events[type]=prepend?[listener,existing]:[existing,listener]:prepend?existing.unshift(listener):existing.push(listener),existing.warned||(prepend=$getMaxListeners(target))&&0<prepend&&existing.length>prepend&&(existing.warned=!0,(prepend=new Error("Possible EventEmitter memory leak detected. "+existing.length+" "+type+" listeners added. Use emitter.setMaxListeners() to increase limit")).name="MaxListenersExceededWarning",prepend.emitter=target,prepend.type=type,prepend.count=existing.length,prepend=prepend,"function"==typeof console.warn?console.warn(prepend):console.log(prepend))):(existing=events[type]=listener,++target._eventsCount),target}function _onceWrap(target,type,listener){var fired=!1;function g(){target.removeListener(type,g),fired||(fired=!0,listener.apply(target,arguments))}return g.listener=listener,g}function listenerCount(type){var events=this._events;if(events){events=events[type];if("function"==typeof events)return 1;if(events)return events.length}return 0}function arrayClone(arr,i){for(var copy=new Array(i);i--;)copy[i]=arr[i];return copy}EventHandlers.prototype=Object.create(null),(EventEmitter.EventEmitter=EventEmitter).usingDomains=!1,EventEmitter.prototype.domain=void 0,EventEmitter.prototype._events=void 0,EventEmitter.prototype._maxListeners=void 0,EventEmitter.defaultMaxListeners=10,EventEmitter.init=function(){this.domain=null,EventEmitter.usingDomains&&(void 0).active,this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=new EventHandlers,this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},EventEmitter.prototype.setMaxListeners=function(n){if("number"!=typeof n||n<0||isNaN(n))throw new TypeError('"n" argument must be a positive number');return this._maxListeners=n,this},EventEmitter.prototype.getMaxListeners=function(){return $getMaxListeners(this)},EventEmitter.prototype.emit=function(type){var handler,args,i,doError="error"===type,events=this._events;if(events)doError=doError&&null==events.error;else if(!doError)return!1;if(domain=this.domain,doError){var domain,doError=arguments[1];if(domain)return(doError=doError||new Error('Uncaught, unspecified "error" event')).domainEmitter=this,doError.domain=domain,doError.domainThrown=!1,domain.emit("error",doError),!1;throw doError instanceof Error?doError:((domain=new Error('Uncaught, unspecified "error" event. ('+doError+")")).context=doError,domain)}if(!(handler=events[type]))return!1;var len,isFn="function"==typeof handler;switch(len=arguments.length){case 1:!function(handler,isFn,self){if(isFn)handler.call(self);else for(var len=handler.length,listeners=arrayClone(handler,len),i=0;i<len;++i)listeners[i].call(self)}(handler,isFn,this);break;case 2:!function(handler,isFn,self,arg1){if(isFn)handler.call(self,arg1);else for(var len=handler.length,listeners=arrayClone(handler,len),i=0;i<len;++i)listeners[i].call(self,arg1)}(handler,isFn,this,arguments[1]);break;case 3:!function(handler,isFn,self,arg1,arg2){if(isFn)handler.call(self,arg1,arg2);else for(var len=handler.length,listeners=arrayClone(handler,len),i=0;i<len;++i)listeners[i].call(self,arg1,arg2)}(handler,isFn,this,arguments[1],arguments[2]);break;case 4:!function(handler,isFn,self,arg1,arg2,arg3){if(isFn)handler.call(self,arg1,arg2,arg3);else for(var len=handler.length,listeners=arrayClone(handler,len),i=0;i<len;++i)listeners[i].call(self,arg1,arg2,arg3)}(handler,isFn,this,arguments[1],arguments[2],arguments[3]);break;default:for(args=new Array(len-1),i=1;i<len;i++)args[i-1]=arguments[i];!function(handler,isFn,self,args){if(isFn)handler.apply(self,args);else for(var len=handler.length,listeners=arrayClone(handler,len),i=0;i<len;++i)listeners[i].apply(self,args)}(handler,isFn,this,args)}return!0},EventEmitter.prototype.on=EventEmitter.prototype.addListener=function(type,listener){return _addListener(this,type,listener,!1)},EventEmitter.prototype.prependListener=function(type,listener){return _addListener(this,type,listener,!0)},EventEmitter.prototype.once=function(type,listener){if("function"!=typeof listener)throw new TypeError('"listener" argument must be a function');return this.on(type,_onceWrap(this,type,listener)),this},EventEmitter.prototype.prependOnceListener=function(type,listener){if("function"!=typeof listener)throw new TypeError('"listener" argument must be a function');return this.prependListener(type,_onceWrap(this,type,listener)),this},EventEmitter.prototype.removeListener=function(type,listener){var list,events,position,i,originalListener;if("function"!=typeof listener)throw new TypeError('"listener" argument must be a function');if((events=this._events)&&(list=events[type]))if(list===listener||list.listener&&list.listener===listener)0==--this._eventsCount?this._events=new EventHandlers:(delete events[type],events.removeListener&&this.emit("removeListener",type,list.listener||listener));else if("function"!=typeof list){for(position=-1,i=list.length;0<i--;)if(list[i]===listener||list[i].listener&&list[i].listener===listener){originalListener=list[i].listener,position=i;break}if(position<0)return this;if(1===list.length){if(list[0]=void 0,0==--this._eventsCount)return this._events=new EventHandlers,this;delete events[type]}else!function(list,index){for(var i=index,k=i+1,n=list.length;k<n;i+=1,k+=1)list[i]=list[k];list.pop()}(list,position);events.removeListener&&this.emit("removeListener",type,originalListener||listener)}return this},EventEmitter.prototype.off=function(type,listener){return this.removeListener(type,listener)},EventEmitter.prototype.removeAllListeners=function(type){var listeners,events=this._events;if(events)if(events.removeListener){if(0===arguments.length){for(var key,keys=Object.keys(events),i=0;i<keys.length;++i)"removeListener"!==(key=keys[i])&&this.removeAllListeners(key);this.removeAllListeners("removeListener"),this._events=new EventHandlers,this._eventsCount=0}else if("function"==typeof(listeners=events[type]))this.removeListener(type,listeners);else if(listeners)for(;this.removeListener(type,listeners[listeners.length-1]),listeners[0];);}else 0===arguments.length?(this._events=new EventHandlers,this._eventsCount=0):events[type]&&(0==--this._eventsCount?this._events=new EventHandlers:delete events[type]);return this},EventEmitter.prototype.listeners=function(type){var events=this._events,type=events&&(events=events[type])?"function"==typeof events?[events.listener||events]:function(arr){for(var ret=new Array(arr.length),i=0;i<ret.length;++i)ret[i]=arr[i].listener||arr[i];return ret}(events):[];return type},EventEmitter.listenerCount=function(emitter,type){return"function"==typeof emitter.listenerCount?emitter.listenerCount(type):listenerCount.call(emitter,type)},EventEmitter.prototype.listenerCount=listenerCount,EventEmitter.prototype.eventNames=function(){return 0<this._eventsCount?Reflect.ownKeys(this._events):[]};let getRandomValues,rnds8=new Uint8Array(16);function rng(){if(getRandomValues=getRandomValues||"undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto))return getRandomValues(rnds8);throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported")}let byteToHex=[];for(let i=0;i<256;++i)byteToHex.push((i+256).toString(16).slice(1));var native={randomUUID:"undefined"!=typeof crypto&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};function v4(options,buf){return!native.randomUUID||buf||options?((buf=(options=options||{}).random||(options.rng||rng)())[6]=15&buf[6]|64,buf[8]=63&buf[8]|128,function(arr,offset=0){return(byteToHex[arr[offset+0]]+byteToHex[arr[offset+1]]+byteToHex[arr[offset+2]]+byteToHex[arr[offset+3]]+"-"+byteToHex[arr[offset+4]]+byteToHex[arr[offset+5]]+"-"+byteToHex[arr[offset+6]]+byteToHex[arr[offset+7]]+"-"+byteToHex[arr[offset+8]]+byteToHex[arr[offset+9]]+"-"+byteToHex[arr[offset+10]]+byteToHex[arr[offset+11]]+byteToHex[arr[offset+12]]+byteToHex[arr[offset+13]]+byteToHex[arr[offset+14]]+byteToHex[arr[offset+15]]).toLowerCase()}(buf)):native.randomUUID()}function makeRequest(_request,_id,_callback){let id=_id||v4();var _id=_request.method,_request=_request.params,request={id:id,method:_id,params:_request};if(this._connMgr?.isReady)if(this._connMgr.status[0].isOpen||this._connMgr.status[1].isOpen||this._connMgr.status[2].isOpen)for(let i=0;i<this._connMgr.pool.length;i++)this._connMgr.status[i].isOpen&&this._connMgr.pool[i].send(JSON.stringify(request)+"\n");else this._requestQueue.push(request);else this._requestQueue.push(request);let self=this;return new Promise(function(_resolve,_reject){self._connMgr.requests[id]={},self._connMgr.requests[id].callback=_callback,self._connMgr.requests[id].resolve=_resolve,self._connMgr.requests[id].reject=_reject,self._connMgr.isReady=!0})}async function getConnection(_connid){if("undefined"!=typeof process&&process?.env?.ROSTRUM)return new WebSocket(process.env.ROSTRUM);if("undefined"!=typeof process&&process?.env?.TESTNET)return new WebSocket("wss://rostrum.test-nexa.sh:30004");switch(_connid){case 0:return new WebSocket("wss://rostrum.nexa.sh:20004");case 1:return new WebSocket("wss://electrum.nexa.org:20004");case 2:return new WebSocket("wss://rostrum.apecs.dev:20004");default:return new WebSocket("wss://rostrum.nexa.sh:20004")}}function initConnection(_connid){this._connMgr.pool[_connid].onopen=()=>{console.info("Connected to Rostrum ->",_connid,(new Date).getTime()),this._connMgr.status[_connid].isOpen=!0,this._requestQueue.forEach(_request=>{this._connMgr.pool[_connid].send(JSON.stringify(_request)+"\n")})},this._connMgr.pool[_connid].onmessage=async _msg=>{var json;let id,data=_msg?.data;try{if(json=JSON.parse(data),id=data.id,json?.error)return this._connMgr.requests[id]?.reject({error:json.error?.message})}catch(err){return this._connMgr.requests[id]?.reject(err)}if(_msg?.data)try{let data=JSON.parse(_msg.data);data?.id&&(id=data.id,this._connMgr.requests[id]?.resolve(data.result)),data?.params&&(id?this._connMgr.requests[id]?.resolve(data.params):(id=data.params[0],this._connMgr.requests[id]?.callback(data.params)))}catch(err){console.error(err),this._connMgr.requests[id]?.reject(err)}},this._connMgr.pool[_connid].onclose=()=>{console.log("CONNECTION CLOSED",_connid,(new Date).getTime()),this._connMgr.status[_connid].isOpen&&(this._connMgr.status[_connid].isOpen=!1),console.info("Waiting (3000 ms) to reconnect..."),setTimeout(async()=>{this._connMgr.pool[_connid]=await getConnection.bind(this)(_connid),initConnection.bind(this)(_connid)},3e3)},this._connMgr.pool[_connid].onerror=e=>{console.error("ERROR! [ %s ]:",_connid,(new Date).getTime(),e)}}let getAddressBalance=async function(_address,_filter="include_tokens"){return void 0===this?(await Rostrum.init()).getAddressBalance(_address,_filter):(_address={method:"blockchain.address.get_balance",params:[_address,_filter]},makeRequest.bind(this)(_address))},decodeRemoteAddress=async function(_address){return void 0===this?(await Rostrum.init()).decodeRemoteAddress(_address):(_address={method:"blockchain.address.decode",params:[_address]},makeRequest.bind(this)(_address))},getAddressFirstUse=async function(_address,_filter="include_tokens"){return void 0===this?(await Rostrum.init()).getAddressFirstUse(_address,_filter):(_address={method:"blockchain.address.get_first_use",params:[_address,_filter]},makeRequest.bind(this)(_address))},getAddressHistory=async function(_address,_filter="include_tokens"){return void 0===this?(await Rostrum.init()).getAddressHistory(_address,_filter):(_address={method:"blockchain.address.get_history",params:[_address,_filter]},makeRequest.bind(this)(_address))},getAddressMempool=async function(_address,_filter="include_tokens"){return void 0===this?(await Rostrum.init()).getAddressMempool(_address,_filter):(_address={method:"blockchain.address.get_mempool",params:[_address,_filter]},makeRequest.bind(this)(_address))},getAddressScriptHash=async function(_address){return void 0===this?(await Rostrum.init()).getAddressScriptHash(_address):(_address={method:"blockchain.address.get_scripthash",params:[_address]},makeRequest.bind(this)(_address))},getAddressUnspent=async function(_address){return void 0===this?(await Rostrum.init()).getAddressUnspent(_address):(_address={method:"blockchain.address.listunspent",params:[_address]},makeRequest.bind(this)(_address))},getBlock=async function(_hash_or_height){return void 0===this?(await Rostrum.init()).getBlock(_hash_or_height):(_hash_or_height={method:"blockchain.block.get",params:[_hash_or_height]},makeRequest.bind(this)(_hash_or_height))},getTransaction=async function(_id,_verbose=!0){return void 0===this?(await Rostrum.init()).getTransaction(_id):(_id={method:"blockchain.transaction.get",params:[_id,_verbose]},makeRequest.bind(this)(_id))},getAddressTokenBalance=async function(_address,_cursor,_tokenid){let params;return void 0===this?(await Rostrum.init()).getAddressTokenBalance(_address,_cursor,_tokenid):(_cursor={method:"token.address.get_balance",params:params=_cursor?[_address,_cursor,_tokenid]:[_address,_tokenid]},makeRequest.bind(this)(_cursor))},getAddressTokenHistory=async function(_address,_cursor,_tokenid){let params;return void 0===this?(await Rostrum.init()).getAddressTokenHistory(_address,_cursor,_tokenid):(_cursor={method:"token.address.get_history",params:params=_cursor?[_address,_cursor,_tokenid]:[_address,_tokenid]},makeRequest.bind(this)(_cursor))},getAddressTokenMempool=async function(_address,_cursor,_tokenid){let params;return void 0===this?(await Rostrum.init()).getAddressTokenMempool(_address,_cursor,_tokenid):(_cursor={method:"token.address.get_mempool",params:params=_cursor?[_address,_cursor,_tokenid]:[_address,_tokenid]},makeRequest.bind(this)(_cursor))},getAddressTokenUnspent=async function(_address,_cursor,_tokenid){let params;return void 0===this?(await Rostrum.init()).getAddressTokenUnspent(_address,_cursor,_tokenid):(_cursor={method:"token.address.listunspent",params:params=_cursor?[_address,_cursor,_tokenid]:[_address,_tokenid]},makeRequest.bind(this)(_cursor))},getNftList=async function(_tokenid,_cursor){let params;return void 0===this?(await Rostrum.init()).getNftList(_tokenid,_cursor):(_cursor={method:"token.nft.list",params:params=_cursor?[_tokenid,_cursor]:[_tokenid]},makeRequest.bind(this)(_cursor))},getOutpoint=async function(_outpoint_hash){return void 0===this?(await Rostrum.init()).getOutpoint(_outpoint_hash):(_outpoint_hash={method:"blockchain.utxo.get",params:[_outpoint_hash]},makeRequest.bind(this)(_outpoint_hash))},getTip=async function(){var request;return void 0===this?(await Rostrum.init()).getTip():(request={method:"blockchain.headers.tip",params:[]},makeRequest.bind(this)(request))},getTokenHistory=async function(_address,_cursor,_tokenid){let params;return void 0===this?(await Rostrum.init()).getTokenHistory(_address,_cursor,_tokenid):(_cursor={method:"token.transaction.get_history",params:params=_cursor?[_address,_cursor,_tokenid]:[_address,_tokenid]},makeRequest.bind(this)(_cursor))},getGenesisInfo=async function(_tokenid){return void 0===this?(await Rostrum.init()).getGenesisInfo(_tokenid):(_tokenid={method:"token.genesis.info",params:[_tokenid]},makeRequest.bind(this)(_tokenid))},getTokenInfo=getGenesisInfo,subscribeAddress=async function(_address,_handler){var request;return void 0===this?(await Rostrum.init()).subscribeAddress(_address,_handler):(request={method:"blockchain.address.subscribe",params:[_address]},makeRequest.bind(this)(request,_address,_handler))};class Rostrum extends EventEmitter{constructor(_params){console.info("Initializing Rostrum..."),console.log(JSON.stringify(_params,null,2)),super(),this._requestQueue=[],this._connMgr=null}static init(_params){return async function(){var rostrum=new Rostrum(_params);return await rostrum._connect(),rostrum}()}async _connect(){if(globalThis.Nexa.Rostrum._connMgr)this._connMgr=globalThis.Nexa.Rostrum._connMgr;else{this._connMgr={pool:[await getConnection.bind(this)(0),await getConnection.bind(this)(1),await getConnection.bind(this)(2)],status:[{isOpen:!1},{isOpen:!1},{isOpen:!1}],requests:{},isReady:!1},globalThis.Nexa||(globalThis.Nexa={}),globalThis.Nexa.Rostrum||(globalThis.Nexa.Rostrum={}),globalThis.Nexa.Rostrum._connMgr=this._connMgr;for(let i=0;i<this._connMgr.pool.length;i++)initConnection.bind(this)(i);setInterval(()=>this.ping(),6e4)}}get status(){return{requestQueue:this?._requestQueue,isReady:this?._connMgr?.isReady}}getAddressBalance(address,filter){return getAddressBalance.bind(this)(address,filter)}decodeRemoteAddress(address){return decodeRemoteAddress.bind(this)(address)}getAddressFirstUse(address,filter){return getAddressFirstUse.bind(this)(address,filter)}getAddressHistory(address,filter){return getAddressHistory.bind(this)(address,filter)}getAddressMempool(address,filter){return getAddressMempool.bind(this)(address,filter)}getAddressScriptHash(params){return getAddressScriptHash.bind(this)(params)}getAddressUnspent(params){return getAddressUnspent.bind(this)(params)}getBlock(id){return getBlock.bind(this)(id)}getTransaction(id,verbose){return getTransaction.bind(this)(id,verbose)}getGenesisInfo(params){return getGenesisInfo.bind(this)(params)}getTokenInfo(params){return getTokenInfo.bind(this)(params)}getAddressTokenBalance(address,cursor,tokenid){return getAddressTokenBalance.bind(this)(address,cursor,tokenid)}getAddressTokenHistory(address,cursor,tokenid){return getAddressTokenHistory.bind(this)(address,cursor,tokenid)}getAddressTokenMempool(address,cursor,tokenid){return getAddressTokenMempool.bind(this)(address,cursor,tokenid)}getAddressTokenUnspent(address,cursor,tokenid){return getAddressTokenUnspent.bind(this)(address,cursor,tokenid)}getNftList(tokenid,cursor){return getNftList.bind(this)(tokenid,cursor)}getOutpoint(outpoint_hash){return getOutpoint.bind(this)(outpoint_hash)}getTip(){return getTip.bind(this)()}getTokenHistory(address,cursor,tokenid){return getTokenHistory.bind(this)(address,cursor,tokenid)}subscribeAddress(params,handler){return subscribeAddress.bind(this)(params,handler)}ping(){return async function(){var request;return void 0===this?(await Rostrum.init()).ping():(request={method:"server.ping",params:[]},makeRequest.bind(this)(request))}.bind(this)()}}var Nexa={};return Nexa.Rostrum=Rostrum,Nexa.getAddressBalance=getAddressBalance,Nexa.decodeRemoteAddress=decodeRemoteAddress,Nexa.getAddressFirstUse=getAddressFirstUse,Nexa.getAddressHistory=getAddressHistory,Nexa.getAddressMempool=getAddressMempool,Nexa.getAddressScriptHash=getAddressScriptHash,Nexa.getAddressUnspent=getAddressUnspent,Nexa.getGenesisInfo=getGenesisInfo,Nexa.getTokenInfo=getTokenInfo,Nexa.getAddressTokenBalance=getAddressTokenBalance,Nexa.getAddressTokenHistory=getAddressTokenHistory,Nexa.getAddressTokenMempool=getAddressTokenMempool,Nexa.getAddressTokenUnspent=getAddressTokenUnspent,Nexa.getNftList=getNftList,Nexa.getOutpoint=getOutpoint,Nexa.getTip=getTip,Nexa.getTokenHistory=getTokenHistory,Nexa.subscribeAddress=subscribeAddress,Nexa.subscribeOwner=subscribeAddress,globalThis.Nexa={...globalThis.Nexa,...Nexa},exports.Rostrum=Rostrum,exports.decodeRemoteAddress=decodeRemoteAddress,exports.getAddressBalance=getAddressBalance,exports.getAddressFirstUse=getAddressFirstUse,exports.getAddressHistory=getAddressHistory,exports.getAddressMempool=getAddressMempool,exports.getAddressScriptHash=getAddressScriptHash,exports.getAddressTokenBalance=getAddressTokenBalance,exports.getAddressTokenHistory=getAddressTokenHistory,exports.getAddressTokenMempool=getAddressTokenMempool,exports.getAddressTokenUnspent=getAddressTokenUnspent,exports.getAddressUnspent=getAddressUnspent,exports.getBlock=getBlock,exports.getGenesisInfo=getGenesisInfo,exports.getNftList=getNftList,exports.getOutpoint=getOutpoint,exports.getTip=getTip,exports.getTokenHistory=getTokenHistory,exports.getTokenInfo=getTokenInfo,exports.getTransaction=getTransaction,exports.subscribeAddress=subscribeAddress,exports}({});
